;; =============================================================================
;;                             Package Management
;; =============================================================================

(require 'package)
(add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/") t)
(package-initialize)

;; Bootstrap use-package
(unless (package-installed-p 'use-package)
  (package-refresh-contents)
  (package-install 'use-package))
(require 'use-package)
(setq use-package-always-ensure t)

;; =============================================================================
;;                           Custom Functions
;; =============================================================================

;; Remote host
(defun my-sanitize-ssh-value (value)
  "Sanitize SSH config values to prevent path injection.
 Returns VALUE if it contains only safe characters, nil otherwise."
  (when (and value
             (stringp value)
             (not (string-empty-p value))
             (string-match-p "^[a-zA-Z0-9._-]+$" value))
    value))

(defun my-ssh-config-host-alist ()
  "Parse SSH config file and return an alist of (host . user).
 Returns nil if config file doesn't exist or isn't readable."
  (let ((config-file (expand-file-name "~/.ssh/config")))
    (if (not (file-readable-p config-file))
        (progn
          (message "SSH config file not found or not readable: %s" config-file)
          nil)
      (condition-case err
          (let ((lines (split-string (with-temp-buffer
                                       (insert-file-contents config-file)
                                       (buffer-string))
                                     "\n"))
                current-host
                result)
            (dolist (line lines)
              (let ((trimmed-line (string-trim line)))
                (cond
                 ;; Match Host entries (ignore wildcards)
                 ((string-match "^Host[ \t]+\\([^ *?\n]+\\)" trimmed-line)
                  (let ((host (match-string 1 trimmed-line)))
                    (when (my-sanitize-ssh-value host)
                      (setq current-host host))))
                 ;; Match User entries
                 ((and current-host
                       (string-match "^User\\s-+\\([^ \t\n]+\\)" trimmed-line))
                  (let ((user (match-string 1 trimmed-line)))
                    (when (my-sanitize-ssh-value user)
                      (push (cons current-host user) result)
                      (setq current-host nil)))))))
            (nreverse result))
        (error
         (message "Error parsing SSH config: %s" (error-message-string err))
         nil)))))

(defun my-open-remote-nofile ()
  "Prompt for an SSH host and open remote file using the correct user from ssh config."
  (interactive)
  (let* ((host-alist (my-ssh-config-host-alist)))
    (if (null host-alist)
        (message "No SSH hosts found in configuration file")
      (let* ((host (completing-read "SSH host: " (mapcar #'car host-alist) nil t))
             (user (or (cdr (assoc host host-alist)) (user-login-name))))
        (unless (my-sanitize-ssh-value host)
          (error "Invalid host name: %s" host))
        (unless (my-sanitize-ssh-value user)
          (error "Invalid user name: %s" user))

        (let ((remote-path (format "/ssh:%s@%s:/home/%s/nofile"
                                   user host user)))
          (message "Opening %s" remote-path)
          (condition-case err
              (find-file remote-path)
            (error
             (message "Failed to open remote file: %s" (error-message-string err)))))))))

;; Multiple cursors search functions
(defun my-enable-phi-search ()
  (global-set-key (kbd "C-s") #'phi-search)
  (global-set-key (kbd "C-r") #'phi-search-backward))

(defun my-disable-phi-search ()
  (global-set-key (kbd "C-s") #'isearch-forward)
  (global-set-key (kbd "C-r") #'isearch-backward))

;; Navigation Functions
(defun my-pop-local-mark-ring ()
  "Pop to the local mark ring."
  (interactive)
  (set-mark-command t))

;; Window Management Functions
(defun my-kill-last-opened-buffer ()
  "Kill the last opened buffer and its window (useful after grep)."
  (interactive)
  (let ((win-curr (selected-window))
        (win-other (next-window)))
    (select-window win-other)
    (kill-buffer-and-window)
    (select-window win-curr)))

;; Text Manipulation Functions
(defun my-renumber-list (start end &optional num)
  "Renumber the list items in the current START..END region.
If optional prefix arg NUM is given, start numbering from that number
instead of 1."
  (interactive "*r\np")
  (save-excursion
    (goto-char start)
    (let ((num (or num 1)))
    (save-match-data
      (while (re-search-forward "^\\(-* *\\)\\([0-9]+\\)" end t)
        (replace-match (concat (match-string 1) (number-to-string num)))
        (setq num (1+ num)))))))

;; Line Operations
(defun my-join-next-line ()
  "Join next line to the end of current line."
  (interactive)
  (save-excursion
    (move-end-of-line nil)
    (kill-line)
    (just-one-space)))

;; Text Processing
(defun my-sort-ilines ()
  "Sort lines ignoring case."
  (interactive)
  (let ((sort-fold-case t))
    (call-interactively #'sort-lines)))

;; Log file: open <file>:<column>
(defun my-open-error-location--parse (text)
  "Parse TEXT of form filename:line[:col[:]] and return (filename line col)."
  (when (string-match "\\([^:\n]+\\):\\([0-9]+\\)\\(?::\\([0-9]+\\)\\)?" (string-trim text))
    (let* ((file (match-string 1 text))
           (line (string-to-number (match-string 2 text)))
           (col-str (match-string 3 text))
           (col (when col-str (string-to-number col-str))))
      (list file line col))))

(defun my-open-error-location-at-point ()
  "Open file:line:column at point. Path is resolved relative to current buffer's directory."
  (interactive)
  (let* ((line-text (thing-at-point 'line t))
         (parsed (my-open-error-location--parse line-text)))
    (if parsed
        (let* ((rel-file (nth 0 parsed))
               (line (nth 1 parsed))
               (col (nth 2 parsed))
               (base-dir (file-name-directory (or (buffer-file-name) default-directory)))
               (full-path (expand-file-name rel-file base-dir)))
          (if (file-exists-p full-path)
              (let ((target-window (get-window-with-predicate
                                    (lambda (win)
                                      (not (eq win (selected-window)))))))
                (when target-window
                  (select-window target-window))
                ;; Let advice handle positioning
                (find-file (format "%s:%d:%d" full-path line (or col 1))))
            (message "File not found: %s" full-path)))
      (message "No valid filename:line[:column] pattern found at point."))))

(defun my-find-file-noselect--advice-with-line-and-column (orig-fun filename &rest args)
  "Advice to allow find-file to open FILENAME at specific line and column if applicable."
  (save-match-data
    (let* ((parsed (when (string-match "\\([^:\n]+\\):\\([0-9]+\\)\\(?::\\([0-9]+\\)\\)?" (string-trim filename))
                     (list (match-string 1 filename)
                           (string-to-number (match-string 2 filename))
                           (when (match-string 3 filename)
                             (string-to-number (match-string 3 filename))))))
           (file (and parsed (nth 0 parsed)))
           (line (and parsed (nth 1 parsed)))
           (col  (and parsed (nth 2 parsed))))
      ;; Only parse line/col if file part exists
      (if (and file (file-exists-p file))
          (let ((buf (apply orig-fun file args)))
            (when (and (buffer-live-p buf) line (> line 0))
              (with-current-buffer buf
                (goto-char (point-min))
                (forward-line (1- line))
                (when (and col (> col 0))
                  (move-to-column (1- col)))))
            buf)
        ;; fallback to original if no valid existing file or no match
        (apply orig-fun filename args)))))

;; =============================================================================
;;                           Core Emacs Settings
;; =============================================================================

(use-package emacs
  :ensure nil
  :init
  ;; Unset unwanted keybinding
  (global-unset-key (kbd "C-z"))

  :bind
  ;; Function key bindings
  ([f1] . comment-dwim)
  ([f2] . whitespace-mode)
  ;; [f3] => see ag
  ([f4] . my-pop-local-mark-ring)
  ([(shift f4)] . pop-global-mark)
  ([f5] . compile)
  ([f6] . interrupt-and-recompile)
  ([f7] . next-error)
  ([f8] . flycheck-mode)
  ([f12] . enlarge-window)

  ;; Window management with auto-balancing
  ("C-x 2" . (lambda ()
               (interactive)
               (split-window-below)
               (balance-windows)))
  ("C-x 3" . (lambda ()
               (interactive)
               (split-window-right)
               (balance-windows)))
  ("C-x 0" . (lambda ()
               (interactive)
               (delete-window)
               (balance-windows)))

  :config
  ;; Path configuration
  (setq-default
   load-path (cons (expand-file-name "~/.emacs.d/elpa") load-path))

  ;; Editor behavior
  (setq-default
   indent-tabs-mode nil           ; Use spaces instead of tabs
   tab-width 4                    ; Set tab width
   fill-column 80)                ; Set fill column

  ;; UI settings
  (line-number-mode t)            ; Show line numbers
  (column-number-mode t)          ; Show column numbers
  (menu-bar-mode t)               ; Show menu bar
  (tool-bar-mode -1)              ; Hide tool bar
  (scroll-bar-mode -1)            ; Hide scroll bar
  (transient-mark-mode t)         ; Highlight selection
  (delete-selection-mode t)       ; Delete selected text
  (fset 'yes-or-no-p #'y-or-n-p)  ; Use y/n instead of yes/no
  (global-auto-revert-mode t)     ; Auto reload changed files
  (save-place-mode t)             ; Remember cursor position

  ;; Scrolling behavior
  (setq scroll-conservatively 10000
        scroll-margin 3
        scroll-step 1
        auto-window-vscroll nil)

  ;; Various settings
  (setq
   Buffer-menu-name-width 30
   fill-nobreak-predicate '(fill-french-nobreak-p)
   mouse-yank-at-point nil
   read-file-name-completion-ignore-case t
   require-final-newline t
   search-whitespace-regexp nil
   query-replace-highlight t
   vc-follow-symlinks t)          ; Follow symlinks without asking

  ;; Custom variables (now handled in custom.el)

  ;; Custom keybindings through minor mode
  (defvar my-keys-minor-mode-map
    (let ((map (make-sparse-keymap)))
      ;; Window movement
      (define-key map (kbd "M-<left>") #'windmove-left)
      (define-key map (kbd "M-<right>") #'windmove-right)
      (define-key map (kbd "M-<up>") #'windmove-up)
      (define-key map (kbd "M-<down>") #'windmove-down)

      ;; Text operations
      (define-key map (kbd "C-c w d") #'delete-trailing-whitespace)
      (define-key map (kbd "C-x C-k") #'my-kill-last-opened-buffer)
      (define-key map (kbd "C-c C-q") #'gen-quote-word)
      (define-key map (kbd "C-<delete>") #'my-join-next-line)
      (define-key map (kbd "C-c C-s") #'my-sort-ilines)

      ;; Open (jump) file from log
      (define-key map (kbd "C-c C-j") #'my-open-error-location-at-point)

      ;; Open file from ssh
      (global-set-key (kbd "C-c C-f") #'my-open-remote-nofile)

      map)
    "my-keys-minor-mode keymap.")

  (define-minor-mode my-keys-minor-mode
    "A minor mode so that my key settings override annoying major modes."
    :init-value t
    :lighter " my-keys")

  (my-keys-minor-mode t)

  (define-globalized-minor-mode global-my-keys-minor-mode my-keys-minor-mode
    (lambda () (my-keys-minor-mode 1)))
  (global-my-keys-minor-mode 1)

  (when (fboundp 'find-file-noselect)
    (advice-add 'find-file-noselect :around #'my-find-file-noselect--advice-with-line-and-column)))

;; =============================================================================
;;                           Search and Navigation
;; =============================================================================

;; Silver Searcher integration
(use-package ag
  :ensure t
  :bind
  ([f3] . ag)
  ([(shift f3)] . ag-project))

;; Parenthesis handling
(use-package paren
  :ensure t
  :config
  (show-paren-mode t)
  ;; Paren settings now handled in custom.el)

;; Multiple cursors
(use-package multiple-cursors
  :ensure t
  :bind (("C-c e l" . mc/edit-lines)
         ("C->" . mc/mark-next-like-this)
         ("C-<" . mc/mark-previous-like-this)
         ("C-c C->" . mc/mark-all-like-this)))

;; Search with multiple cursors
(use-package phi-search
  :ensure t
  :hook ((multiple-cursors-mode-enabled . my-enable-phi-search)
         (multiple-cursors-mode-disabled . my-disable-phi-search)))

;; Jump to definitions
(use-package dumb-jump
  :ensure t
  :config
  (setq dumb-jump-project-denoters
        '(".dumbjump" ".projectile" ".git" ".hg" ".fslckout"
          ".bzr" "_darcs" ".svn" "PkgInfo" "-pkg.el"))
  (setq dumb-jump-prefer-searcher 'ag)
  :hook ((prog-mode . dumb-jump-mode)
         (xref-backend-functions . #'dumb-jump-xref-activate)
         (c-mode . (lambda ()
                    (setq-local dumb-jump-force-searcher 'ag
                               dumb-jump-functions-only t))))
  :bind (:map dumb-jump-mode-map
              ("C-M-g" . nil)
              ("C-M-p" . nil)
              ("C-M-q" . nil)
              ("C-c C-l" . xref-find-definitions)
              ("C-c C-b" . xref-pop-marker-stack)))

(use-package cl-lib
  :ensure nil
  :demand t)

;; =============================================================================
;;                           Development Tools
;; =============================================================================

;; Completion
(use-package company
  :ensure t
  :hook (after-init . global-company-mode)
  :bind ([C-tab] . company-complete-common)
  :custom
  (company-minimum-prefix-length 2)
  (company-idle-delay 0.2)
  (company-dabbrev-downcase nil)
  (company-tooltip-align-annotations t)
  (company-tooltip-limit 10)
  :config
  ;; Improved completion cycling
  (define-key company-active-map (kbd "C-n") #'company-select-next)
  (define-key company-active-map (kbd "C-p") #'company-select-previous))

;; Compilation
(use-package compile
  :ensure nil
  :custom
  (compilation-scroll-output 'first-error)
  (compilation-window-height 15)
  :commands (interrupt-and-recompile new-compilation-window-hook)
  :bind (("C-c c" . interrupt-and-recompile)
         ("C-c r" . recompile))
  :hook (compilation-mode . new-compilation-window-hook)
  :config
  (defun interrupt-and-recompile ()
    "Interrupt old compilation, if any, and recompile."
    (interactive)
    (let ((compilation-buffer (get-buffer "*compilation*")))
      (when compilation-buffer
        (with-current-buffer compilation-buffer
          (when (get-buffer-process compilation-buffer)
            (interrupt-process (get-buffer-process compilation-buffer))
            (sleep-for 0.1)))  ; Brief pause to allow clean shutdown
        (ignore-errors (kill-buffer compilation-buffer))))
    (recompile))

  (defun new-compilation-window-hook ()
    "Create a new window for compilation buffer if not already visible."
    (unless (get-buffer-window "*compilation*")
      (split-window-vertically (- (window-height) 15))))

  (setq compilation-exit-message-function
        (lambda (status code msg)
          (when (and (eq status 'exit) (zerop code))
            (let ((compilation-buffer (get-buffer "*compilation*")))
              (when compilation-buffer
                (run-with-timer 1 nil
                  (lambda ()
                    (when (get-buffer "*compilation*")
                      (bury-buffer "*compilation*")
                      (when-let ((window (get-buffer-window "*compilation*")))
                        (delete-window window))))))))
          (cons msg code))))

;; ANSI color support in compilation
(use-package ansi-color
  :ensure t
  :hook (compilation-filter . ansi-color-compilation-filter))

;; Ediff configuration
(setq ediff-split-window-function #'split-window-horizontally
      ediff-window-setup-function #'ediff-setup-windows-plain)

;; =============================================================================
;;                           Programming Languages
;; =============================================================================

;; Shell scripting
(setq-default sh-basic-offset 2
              sh-indentation 2)

;; C/C++
(use-package cc-mode
  :ensure t
  :config
  (setq c-default-style "linux"
        c-basic-offset 4)

  ;; ACSL mode configuration
  (defconst acsl-keywords
    '("assert" "assigns" "ensures" "slevel" "slevel_merge" "requires")
    "List of ACSL keywords to highlight.")

  (defun acsl-comment ()
    "Return non-nil if we are in an ACSL comment (/*@ or //@)."
    (and (nth 4 (syntax-ppss)) ; Inside a comment
         (or (and (eq (char-after (+ (nth 8 (syntax-ppss)) 2)) ?@)) ; Check for /*@
             (and (eq (char-after (+ (nth 8 (syntax-ppss)) 2)) ?@))))) ; Check for //@

  (defvar acsl-font-lock-keywords
    (let ((pre-match-form (lambda ()
                            (goto-char (match-beginning 0))
                            (match-end 0)))
          (find-annot (lambda (limit)
                        ;; Skip non-ACSL comments
                        (if (and (looking-at "//") (acsl-comment))
                            (re-search-forward "\n" limit t))
                        (while (and (not (acsl-comment)) (< (point) limit))
                          (re-search-forward "/[*/]" limit t))
                        (if (>= (point) limit)
                            nil
                          (let ((b (save-excursion
                                     (re-search-backward "/[*/]" (- (point) 2) t)
                                     (point))))
                            (re-search-forward "[*/]/\\|\n" limit t)
                            (re-search-backward "//" (- (point) 2) t) ; Don't recolor comments
                            (set-match-data (list b (point) (nth 2 (match-data t))))
                            t)))))
      (list
       `(,find-annot
         (0 'font-lock-doc-face t)
         (,(concat (regexp-opt acsl-keywords 'words) "") (,pre-match-form) nil
          (0 '(font-lock-doc-face :inherit bold) t)))))
    "Default highlighting for ACSL mode")

  (defun my-acsl-mode ()
    "Enable ACSL (ANSI/ISO C Specification Language) syntax highlighting."
    (font-lock-add-keywords nil acsl-font-lock-keywords))

  (defun my-cc-style ()
    "Set custom C/C++ style with Linux base and custom offsets."
    (c-set-style "linux")
    (c-set-offset 'innamespace 0)
    (c-set-offset 'inextern-lang 0)
    (c-set-offset 'inline-open 0)
    (c-set-offset 'label '*)
    (c-set-offset 'case-label '*)
    (c-set-offset 'access-label '/)
    (setq c-basic-offset 4))

  (defun my-cc-clang-format-keys ()
    "Set custom keybindings for clang-format in C/C++ modes."
    (local-set-key (kbd "C-M-\\") #'clang-format-region))

  (defun my-cc-mode-setup ()
    "Setup function for C/C++ modes."
    (my-cc-style)
    (my-cc-clang-format-keys)
    (my-acsl-mode))

  (add-to-list 'auto-mode-alist '("\\.ipp\\'" . c++-mode))

  :hook ((c++-mode . my-cc-mode-setup)
         (c-mode . my-cc-mode-setup)))

(use-package clang-format
  :ensure t
  :after cc-mode)

;; Python Configuration
(use-package python
  :ensure nil
  :config
  (setq python-indent-offset 4
        python-indent-guess-indent-offset-verbose nil))

(use-package flycheck
  :ensure t
  :hook (python-mode . flycheck-mode)
  :config
  (when (executable-find "pylint3")
    (setq flycheck-python-pylint-executable "pylint3"))
  (setq flycheck-python-mypy-cache-dir "/dev/null"))

;; OCaml Configuration
(use-package tuareg
  :ensure t
  :mode ("\\.ocamlinit\\'" . tuareg-mode))

(use-package dune
  :ensure t)

(use-package merlin
  :ensure t
  :hook ((tuareg-mode . merlin-mode)
         (merlin-mode . company-mode))
  :config (setq merlin-error-after-save nil))

(use-package merlin-eldoc
  :ensure t
  :hook (tuareg-mode . merlin-eldoc-setup))

(use-package flycheck-ocaml
  :ensure t
  :config (flycheck-ocaml-setup))

;; =============================================================================
;;                           Markup and Config Languages
;; =============================================================================

;; Markdown
(use-package markdown-mode
  :ensure t
  :mode (("\\.md\\'" . markdown-mode)
         ("\\.markdown\\'" . markdown-mode))
  :init
  (setq markdown-command "multimarkdown"))

;; JSON
(use-package json-mode
  :ensure t
  :mode "\\.json\\'"
  :bind (:map json-mode-map
              ("C-M-\\" . json-reformat-region)))

;; Configuration files
(use-package conf-mode
  :ensure nil
  :mode
  (("/\\.[^/]*rc\\'" . conf-unix-mode)
   ("/config\\'" . conf-unix-mode)
   ("/gitconfig\\'" . conf-unix-mode)
   ("/tmux\\'" . conf-unix-mode)))

;; JavaScript/TypeScript
(use-package typescript-mode
  :ensure t
  :mode "\\.tsx\\'")

;; Makefile
(use-package make-mode
  :ensure nil
  :mode "Makefile\\.inc\\'")

;; =============================================================================
;;                           Text and Spelling
;; =============================================================================

;; Spelling configuration
(use-package ispell
  :ensure nil
  :hook (markdown-mode . custom-ispell)
  :config
  (when (executable-find "hunspell")
    (setq-default ispell-program-name "hunspell")
    (setq ispell-really-hunspell t))

  (defun custom-ispell ()
    "Skip regions from spell checking."
    (make-local-variable 'ispell-skip-region-alist)
    (add-to-list 'ispell-skip-region-alist '("`" . "`"))
    (add-to-list 'ispell-skip-region-alist '("^```" . "```$"))))

;; =============================================================================
;;                           Visual Enhancement
;; =============================================================================

;; Whitespace visualization
(use-package whitespace
  :ensure nil
  :hook (prog-mode . whitespace-mode)
  :custom
  (whitespace-style '(face trailing empty lines-tail tabs tab-mark))
  (whitespace-space 'whitespace-hspace)
  (whitespace-line-column 80)
  :config
  ;; Set region highlight
  (set-face-attribute 'region nil :background "SlateGray1")

  ;; Set whitespace faces programmatically (actual faces are defined in custom.el)
  ;; This ensures they work properly with the custom file system

;; =============================================================================
;;                           Final Configuration
;; =============================================================================

;; Move custom-set-variables to a separate file
(setq custom-file (expand-file-name "custom.el" (file-name-directory load-file-name)))
(when (file-exists-p custom-file)
  (load custom-file))

(provide 'init)
;;; init.el ends here
