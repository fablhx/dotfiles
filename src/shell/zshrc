# =============================================================================
#                               Zsh Configuration
# =============================================================================

# Early exit for dumb terminals
[[ $TERM == "dumb" ]] && unsetopt zle && PS1='$ ' && return

# =============================================================================
#                           Shell Options & Completion
# =============================================================================

# Basic shell options
REPORTTIME=10
setopt complete_in_word
setopt notify
setopt prompt_subst

# Completion configuration
zstyle ':completion:*' menu select
zstyle ':completion:*' list-colors ${(s.:.)LS_COLORS}
zstyle ':completion:*' verbose yes
zstyle ':completion:*' group-name ''
zstyle ':completion:*:descriptions' format "$fg[yellow]%B--- %d%b"
zstyle ':completion:*:messages' format '%d'
zstyle ':completion:*:warnings' format "$fg[red]No matches$reset_color"
zstyle ':completion:*:corrections' format '%B%d (errors: %e)%b'

# =============================================================================
#                           History Configuration
# =============================================================================

HISTSIZE=50000
SAVEHIST=50000
setopt append_history
setopt hist_expire_dups_first
setopt hist_find_no_dups
setopt hist_ignore_all_dups
setopt hist_ignore_dups
setopt hist_save_no_dups
setopt inc_append_history
setopt share_history

# =============================================================================
#                           Environment Variables
# =============================================================================

export ALTERNATE_EDITOR=""
export EDITOR='emacs'
export LESS="-RFX"

# =============================================================================
#                           Command Aliases
# =============================================================================

# Enhanced tool detection and alias setup
__setup_modern_aliases() {
    # Core command enhancements
    alias ls='ls --color=auto -v'
    alias grep='grep --color=auto'
    alias fgrep='fgrep --color=auto'
    alias egrep='egrep --color=auto'

    # Modern tool alternatives (with fallbacks)
    if command -v bat >/dev/null 2>&1; then
        alias cat='bat --paging=never --style=plain'
    fi

    # Prefer eza if available
    if command -v eza >/dev/null 2>&1; then
        alias ls='eza --color=auto --group-directories-first'
        alias l='eza -lh'
        alias ll='eza -lh'
        alias lll='eza -lha'
        alias la='eza -d .*'
        alias lt='eza -lht'
    else
        # Fallback to standard ls
        alias l='ls -lh'
        alias ll='ls -lh'
        alias lll='ls -lha'
        alias la='ls -lhd .?*'
        alias lt='ls -lht'
    fi

    # ripgrep with fallback
    command -v rg >/dev/null 2>&1 && alias grep='rg'

    # Tree with colors
    alias tree='tree -C'

    # Clipboard integration
    alias xclip='xclip -selection clipboard'

    # Enhanced safety aliases
    alias rm='rm -I'    # Prompt once if removing 3+ files

    # System integration
    alias xopen='xdg-open'
}

# Initialize aliases
__setup_modern_aliases

# =============================================================================
#                           Emacs Integration
# =============================================================================

# Smart emacsclient function
__emacs_client() {
    # Check if there's already a frame available, reuse it if so
    if emacsclient -n -e "(if (> (length (frame-list)) 1) 't)" 2>/dev/null | grep -q t; then
        emacsclient -n "$@"
    else
        emacsclient -c -n "$@"
    fi
}

# Emacs client aliases
alias cedit='emacsclient -c -nw'    # Console edit
alias wedit='__emacs_client'        # Window edit
alias start_emacs='emacs --daemon'  # Start daemon
alias stop_emacs='emacsclient -e "(kill-emacs)"'  # Stop daemon

# =============================================================================
#                           Git Prompt
# =============================================================================

# Highly optimized Git prompt function with advanced performance improvements
__git_prompt() {
    # Skip git prompt entirely if timeout command is not available
    # This simplifies the git prompt by requiring timeout for all git operations
    command -v timeout >/dev/null 2>&1 || return

    # Early exits and guards for performance
    [[ "$PWD" == *"/.git"* ]] && return  # Skip if inside .git directory
    [[ -d ".git" ]] || git rev-parse --git-dir >/dev/null 2>&1 || return  # Quick git repo check

    # Get git directory for repo size detection
    local git_dir
    git_dir=$(git rev-parse --git-dir 2>/dev/null) || return

    # Intelligent timeout scaling based on repo size
    local base_timeout=0.1
    local fast_timeout=0.05
    local slow_timeout=0.2

    # Detect large repos by .git directory size (approximate)
    if [[ -d "$git_dir/objects/pack" ]] && [[ $(find "$git_dir/objects/pack" -name "*.pack" 2>/dev/null | wc -l) -gt 5 ]]; then
        # Large repo detected - use faster timeouts and skip expensive operations
        base_timeout=0.05
        fast_timeout=0.03
        slow_timeout=0.1
        local large_repo=true
    else
        local large_repo=false
    fi

    # Colors for zsh
    local color_detached="%{\033[38;5;200m%}"
    local color_dirty="%{\033[38;5;240m%}"
    local color_clean="%{\033[38;5;22m%}"
    local color_behind="%{\033[38;5;250m%}"
    local color_ahead="%{\033[38;5;250m%}"
    local color_staged="%{\033[38;5;28m%}"
    local color_unmerged="%{\033[38;5;196m%}"
    local color_changed="%{\033[38;5;166m%}"
    local color_untracked="%{\033[38;5;172m%}"
    local color_stashed="%{\033[38;5;26m%}"
    local reset_color="%{\033[0m%}"

    # Initialize variables
    local branch="" detached="no" behind=0 ahead=0
    local staged=0 unmerged=0 changed=0 untracked=0 stashed=0

    # Get branch name separately for better reliability
    branch=$(timeout "${fast_timeout}s" git symbolic-ref --short -q HEAD 2>/dev/null)

    # Handle detached HEAD case
    if [[ -z "$branch" ]]; then
        detached="yes"
        branch=$(timeout "${base_timeout}s" git describe --exact-match --tags HEAD 2>/dev/null || timeout "${base_timeout}s" git rev-parse --short HEAD 2>/dev/null)
    fi

    # Get status information with progressive fallback strategy
    local git_status_combined=""
    local using_fallback=false

    # Try git status with timeout
    git_status_combined=$(timeout "${fast_timeout}s" git status --porcelain=v1 --untracked-files=no 2>/dev/null)

    # If git status times out or fails, fall back to git diff --name-only
    if [[ $? -ne 0 ]]; then
        using_fallback=true
        # Get staged changes (index vs HEAD) and unstaged changes in parallel
        local staged_files changed_files
        timeout "${fast_timeout}s" git diff --cached --name-only 2>/dev/null > /tmp/staged_$$ &
        local staged_pid=$!
        timeout "${fast_timeout}s" git diff --name-only 2>/dev/null > /tmp/changed_$$ &
        local changed_pid=$!

        wait $staged_pid; staged_files=$(cat /tmp/staged_$$ 2>/dev/null)
        wait $changed_pid; changed_files=$(cat /tmp/changed_$$ 2>/dev/null)
        rm -f /tmp/staged_$$ /tmp/changed_$$

        # Build status more efficiently
        git_status_combined=""
        [[ -n "$staged_files" ]] && while read -r file; do git_status_combined+="M  $file"$'\n'; done <<< "$staged_files"
        [[ -n "$changed_files" ]] && while read -r file; do git_status_combined+=" M $file"$'\n'; done <<< "$changed_files"
    fi

    # Get ahead/behind information separately if needed
    if [[ "$detached" != "yes" ]]; then
        local upstream
        upstream=$(timeout "${fast_timeout}s" git rev-parse --abbrev-ref @{upstream} 2>/dev/null)

        if [[ -n "$upstream" ]]; then
            local ahead_behind
            ahead_behind=$(timeout "${fast_timeout}s" git rev-list --left-right --count HEAD..."$upstream" 2>/dev/null)

            # If that times out, try merge-base approach for faster check
            if [[ $? -ne 0 ]]; then
                local merge_base=$(timeout "${fast_timeout}s" git merge-base HEAD "$upstream" 2>/dev/null)
                if [[ -n "$merge_base" ]]; then
                    local head_commit=$(timeout "${fast_timeout}s" git rev-parse HEAD 2>/dev/null)
                    local upstream_commit=$(timeout "${fast_timeout}s" git rev-parse "$upstream" 2>/dev/null)

                    if [[ -n "$head_commit" && -n "$upstream_commit" ]]; then
                        [[ "$merge_base" != "$head_commit" ]] && ahead="?"  # We're ahead, unknown count
                        [[ "$merge_base" != "$upstream_commit" ]] && behind="?"  # We're behind, unknown count
                    fi
                fi
            fi

            if [[ -n "$ahead_behind" ]]; then
                ahead=$(echo "$ahead_behind" | cut -f1)
                behind=$(echo "$ahead_behind" | cut -f2)
            fi
        fi
    fi

    # Process status information with shell built-ins (optimization)
    if [[ -n "$git_status_combined" ]]; then
        # Process all file status lines directly
        local status_lines
        status_lines="$git_status_combined"

        # Use shell parameter expansion instead of AWK for better performance
        while IFS= read -r line; do
            [[ -z "$line" ]] && continue

            local index_status="${line[1]}"
            local worktree_status="${line[2]}"

            # Count staged files
            case "$index_status" in
                [MADRC]) ((staged++)) ;;
                U) ((unmerged++)) ;;
            esac

            # Count changed files
            case "$worktree_status" in
                [MD]) ((changed++)) ;;
                U) ((unmerged++)) ;;
            esac
        done <<< "$status_lines"
    fi

    # Untracked files with timeout (skip in large repos for performance)
    if [[ "$large_repo" != "true" ]]; then
        local untracked_files
        untracked_files=$(timeout "${slow_timeout}s" git ls-files --others --exclude-standard 2>/dev/null)

        # Count untracked files if we got them
        if [[ -n "$untracked_files" ]]; then
            untracked=$(printf '%s\n' "$untracked_files" | wc -l)
        fi
    fi

    # Conditional stash counting (skip in large repos or if stash is old)
    if [[ "$large_repo" != "true" ]] && [[ -f "$git_dir/refs/stash" ]]; then
        # Only check stash if it was modified recently (within 24 hours)
        if [[ $(find "$git_dir/refs/stash" -mtime -1 2>/dev/null) ]]; then
            stashed=$(timeout "${base_timeout}s" git rev-list --walk-reflogs --count refs/stash 2>/dev/null || echo 0)
        fi
    fi

    # Set branch color based on repository state
    local color_branch
    if [[ "$detached" == "yes" ]]; then
        color_branch="$color_detached"
    elif [[ "$staged" -ne 0 || "$unmerged" -ne 0 || "$changed" -ne 0 || "$untracked" -ne 0 ]]; then
        color_branch="$color_dirty"
    else
        color_branch="$color_clean"
    fi

    # Build prompt string efficiently
    local git_prompt=" $color_branch$branch${reset_color}"

    [[ "$behind" -gt 0 ]] && git_prompt+=" $color_behind↓$behind${reset_color}"
    [[ "$ahead" -gt 0 ]] && git_prompt+=" $color_ahead↑$ahead${reset_color}"
    [[ "$staged" -gt 0 ]] && git_prompt+=" $color_staged•$staged${reset_color}"
    [[ "$unmerged" -gt 0 ]] && git_prompt+=" $color_unmerged$unmerged${reset_color}"
    [[ "$changed" -gt 0 ]] && git_prompt+=" $color_changed+$changed${reset_color}"
    [[ "$untracked" -gt 0 ]] && git_prompt+=" $color_untracked…$untracked${reset_color}"
    [[ "$stashed" -gt 0 ]] && git_prompt+=" $color_stashed⚑$stashed${reset_color}"

    echo "$git_prompt"
}

# =============================================================================
#                           Prompt Configuration
# =============================================================================

# Build custom prompt with git information
__build_prompt() {
    local exit_code="$?"

    # Base prompt: user@host working_directory
    PROMPT=$'%{\033[38;5;135m%}%n@%m%{\033[0m%} %4(c:…/:)%3c'

    # Add git information
    PROMPT+="$(__git_prompt)"

    # Add exit code if non-zero
    test "$exit_code" -eq 0 || PROMPT+=$' %{\033[38;5;196m%}[${exit_code}]%{\033[0m%}'

    # Final prompt character
    PROMPT+=' %# '
}

# Set prompt command
precmd() { __build_prompt; }
