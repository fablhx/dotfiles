# =============================================================================
#                               Zsh Configuration
# =============================================================================

# Early exit for dumb terminals
[[ $TERM == "dumb" ]] && unsetopt zle && PS1='$ ' && return

# =============================================================================
#                           Shell Options & Completion
# =============================================================================

# Basic shell options
REPORTTIME=10
setopt complete_in_word
setopt notify
setopt prompt_subst

# Completion configuration
zstyle ':completion:*' menu select
zstyle ':completion:*' list-colors ${(s.:.)LS_COLORS}
zstyle ':completion:*' verbose yes
zstyle ':completion:*' group-name ''
zstyle ':completion:*:descriptions' format "$fg[yellow]%B--- %d%b"
zstyle ':completion:*:messages' format '%d'
zstyle ':completion:*:warnings' format "$fg[red]No matches$reset_color"
zstyle ':completion:*:corrections' format '%B%d (errors: %e)%b'

# =============================================================================
#                           History Configuration
# =============================================================================

HISTSIZE=50000
SAVEHIST=50000
setopt append_history
setopt hist_expire_dups_first
setopt hist_find_no_dups
setopt hist_ignore_all_dups
setopt hist_ignore_dups
setopt hist_save_no_dups
setopt inc_append_history
setopt share_history

# =============================================================================
#                           Environment Variables
# =============================================================================

export ALTERNATE_EDITOR=""
export EDITOR='emacs'
export LESS="-RFX"

# =============================================================================
#                           Command Aliases
# =============================================================================

# Enhanced tool detection and alias setup
__setup_modern_aliases() {
    # Core command enhancements
    alias ls='ls --color=auto -v'
    alias grep='grep --color=auto'
    alias fgrep='fgrep --color=auto'
    alias egrep='egrep --color=auto'

    # Modern tool alternatives (with fallbacks)
    if command -v bat >/dev/null 2>&1; then
        alias cat='bat --paging=never --style=plain'
    fi

    # Prefer eza if available
    if command -v eza >/dev/null 2>&1; then
        alias ls='eza --color=auto --group-directories-first'
        alias l='eza -lh'
        alias ll='eza -lh'
        alias lll='eza -lha'
        alias la='eza -d .*'
        alias lt='eza -lht'
    else
        # Fallback to standard ls
        alias l='ls -lh'
        alias ll='ls -lh'
        alias lll='ls -lha'
        alias la='ls -lhd .?*'
        alias lt='ls -lht'
    fi

    # ripgrep with fallback
    command -v rg >/dev/null 2>&1 && alias grep='rg'

    # Tree with colors
    alias tree='tree -C'

    # Clipboard integration
    alias xclip='xclip -selection clipboard'

    # Enhanced safety aliases
    alias rm='rm -I'    # Prompt once if removing 3+ files

    # System integration
    alias xopen='xdg-open'
}

# Initialize aliases
__setup_modern_aliases

# =============================================================================
#                           Emacs Integration
# =============================================================================

# Smart emacsclient function
__emacs_client() {
    # Check if there's already a frame available, reuse it if so
    if emacsclient -n -e "(if (> (length (frame-list)) 1) 't)" 2>/dev/null | grep -q t; then
        emacsclient -n "$@"
    else
        emacsclient -c -n "$@"
    fi
}

# Emacs client aliases
alias cedit='emacsclient -c -nw'    # Console edit
alias wedit='__emacs_client'        # Window edit
alias start_emacs='emacs --daemon'  # Start daemon
alias stop_emacs='emacsclient -e "(kill-emacs)"'  # Stop daemon

# =============================================================================
#                           Git Prompt
# =============================================================================

# Optimized Git prompt function with timeouts and performance improvements
__git_prompt() {
    # Quick check if we're in a git repo with timeout
    local git_dir
    if command -v timeout >/dev/null 2>&1; then
        git_dir=$(timeout 0.2s git rev-parse --git-dir 2>/dev/null) || return
    else
        git_dir=$(git rev-parse --git-dir 2>/dev/null) || return
    fi

    # Colors for zsh
    local color_detached="%{\033[38;5;200m%}"
    local color_dirty="%{\033[38;5;240m%}"
    local color_clean="%{\033[38;5;22m%}"
    local color_behind="%{\033[38;5;250m%}"
    local color_ahead="%{\033[38;5;250m%}"
    local color_staged="%{\033[38;5;28m%}"
    local color_unmerged="%{\033[38;5;196m%}"
    local color_changed="%{\033[38;5;166m%}"
    local color_untracked="%{\033[38;5;172m%}"
    local color_stashed="%{\033[38;5;26m%}"
    local reset_color="%{\033[0m%}"

    # Initialize variables
    local branch="" detached="no" behind=0 ahead=0
    local staged=0 unmerged=0 changed=0 untracked=0 stashed=0

    # Get branch name with timeout
    if command -v timeout >/dev/null 2>&1; then
        branch=$(timeout 0.1s git symbolic-ref --short -q HEAD 2>/dev/null)
    else
        branch=$(git symbolic-ref --short -q HEAD 2>/dev/null)
    fi

    if [[ -z "$branch" ]]; then
        # Detached HEAD state
        detached="yes"
        if command -v timeout >/dev/null 2>&1; then
            branch=$(timeout 0.1s git describe --exact-match --tags HEAD 2>/dev/null || timeout 0.1s git rev-parse --short HEAD 2>/dev/null)
        else
            branch=$(git describe --exact-match --tags HEAD 2>/dev/null || git rev-parse --short HEAD 2>/dev/null)
        fi
    else
        # Get ahead/behind count with timeout
        local upstream
        if command -v timeout >/dev/null 2>&1; then
            upstream=$(timeout 0.1s git for-each-ref --format='%(upstream:short)' "$(git symbolic-ref -q HEAD)" 2>/dev/null)
        else
            upstream=$(git for-each-ref --format='%(upstream:short)' "$(git symbolic-ref -q HEAD)" 2>/dev/null)
        fi

        if [[ -n "$upstream" ]]; then
            local ahead_behind
            if command -v timeout >/dev/null 2>&1; then
                ahead_behind=$(timeout 0.15s git rev-list --left-right --count "$upstream...HEAD" 2>/dev/null)
            else
                ahead_behind=$(git rev-list --left-right --count "$upstream...HEAD" 2>/dev/null)
            fi

            if [[ -n "$ahead_behind" ]]; then
                behind=${ahead_behind%%[[:space:]]*}
                ahead=${ahead_behind##*[[:space:]]}
            fi
        fi
    fi

    # Get repository status with timeout
    local git_status
    if command -v timeout >/dev/null 2>&1; then
        git_status=$(timeout 0.2s git status --porcelain=v1 2>/dev/null)
    else
        git_status=$(git status --porcelain=v1 2>/dev/null)
    fi

    # Process status information
    if [[ -n "$git_status" ]]; then
        local counts
        counts=$(printf '%s\n' "$git_status" | awk '
            BEGIN { staged=0; unmerged=0; changed=0; untracked=0 }
            /^[MADRC]/ { staged++ }
            /^UU|^AA|^DD/ { unmerged++ }
            /^.[MD]/ { changed++ }
            /^\?\?/ { untracked++ }
            END { printf "%d %d %d %d\n", staged, unmerged, changed, untracked }
        ')
        local -a count_array=(${=counts})
        staged=${count_array[1]}
        unmerged=${count_array[2]}
        changed=${count_array[3]}
        untracked=${count_array[4]}
    fi

    # Get stash count only if stashes exist (performance optimization)
    if [[ -f "$git_dir/refs/stash" ]]; then
        if command -v timeout >/dev/null 2>&1; then
            stashed=$(timeout 0.1s git rev-list --walk-reflogs --count refs/stash 2>/dev/null || echo 0)
        else
            stashed=$(git rev-list --walk-reflogs --count refs/stash 2>/dev/null || echo 0)
        fi
    fi

    # Set branch color based on repository state
    local color_branch
    if [[ "$detached" == "yes" ]]; then
        color_branch="$color_detached"
    elif [[ "$staged" -ne 0 || "$unmerged" -ne 0 || "$changed" -ne 0 || "$untracked" -ne 0 ]]; then
        color_branch="$color_dirty"
    else
        color_branch="$color_clean"
    fi

    # Build prompt string efficiently
    local git_prompt=" $color_branch$branch${reset_color}"

    [[ "$behind" -gt 0 ]] && git_prompt+=" $color_behind↓$behind${reset_color}"
    [[ "$ahead" -gt 0 ]] && git_prompt+=" $color_ahead↑$ahead${reset_color}"
    [[ "$staged" -gt 0 ]] && git_prompt+=" $color_staged•$staged${reset_color}"
    [[ "$unmerged" -gt 0 ]] && git_prompt+=" $color_unmerged$unmerged${reset_color}"
    [[ "$changed" -gt 0 ]] && git_prompt+=" $color_changed+$changed${reset_color}"
    [[ "$untracked" -gt 0 ]] && git_prompt+=" $color_untracked…$untracked${reset_color}"
    [[ "$stashed" -gt 0 ]] && git_prompt+=" $color_stashed⚑$stashed${reset_color}"

    echo "$git_prompt"
}

# =============================================================================
#                           Prompt Configuration
# =============================================================================

# Build custom prompt with git information
__build_prompt() {
    local exit_code="$?"

    # Base prompt: user@host working_directory
    PROMPT=$'%{\033[38;5;135m%}%n@%m%{\033[0m%} %4(c:…/:)%3c'

    # Add git information
    PROMPT+="$(__git_prompt)"

    # Add exit code if non-zero
    test "$exit_code" -eq 0 || PROMPT+=$' %{\033[38;5;196m%}[${exit_code}]%{\033[0m%}'

    # Final prompt character
    PROMPT+=' %# '
}

# Set prompt command
precmd() { __build_prompt; }