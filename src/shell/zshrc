# =============================================================================
#                               Zsh Configuration
#                            (Warp Terminal / Linux)
# =============================================================================

# Early exit for dumb terminals
[[ $TERM == "dumb" ]] && unsetopt zle && PS1='$ ' && return

# =============================================================================
#                           Shell Options
# =============================================================================

REPORTTIME=10
setopt auto_cd             # cd by typing directory name
setopt complete_in_word    # Complete from both ends of a word
setopt correct             # Autocorrect minor command typos
setopt extended_glob       # Extended pattern matching (#, ~, ^)
setopt glob_dots           # Include dotfiles in globbing
setopt notify              # Report background job status immediately
setopt prompt_subst        # Enable prompt substitution

# =============================================================================
#                           Shell Completion
# =============================================================================

autoload -Uz compinit && compinit

zstyle ':completion:*' menu select
zstyle ':completion:*' list-colors ${(s.:.)LS_COLORS}
zstyle ':completion:*' verbose yes
zstyle ':completion:*' group-name ''
zstyle ':completion:*' matcher-list 'm:{a-zA-Z}={A-Za-z}' # Case-insensitive
zstyle ':completion:*:descriptions' format '%F{yellow}%B--- %d%b%f'
zstyle ':completion:*:messages' format '%d'
zstyle ':completion:*:warnings' format '%F{red}No matches%f'
zstyle ':completion:*:corrections' format '%B%d (errors: %e)%b'

# =============================================================================
#                           History Configuration
# =============================================================================

HISTFILE="${HOME}/.zsh_history"
HISTSIZE=50000
SAVEHIST=50000

setopt append_history
setopt hist_expire_dups_first
setopt hist_find_no_dups
setopt hist_ignore_all_dups
setopt hist_ignore_dups
setopt hist_ignore_space         # Ignore commands starting with space
setopt hist_save_no_dups
setopt inc_append_history
setopt share_history

# Filter common commands from history
zshaddhistory() {
    local cmd="${1%%$'\n'}"
    local word="${cmd%% *}"
    case "$word" in
        ls|ll|la|l|cd|pwd|exit|clear|history|bg|fg|jobs) return 1 ;;
    esac
    return 0
}

# =============================================================================
#                           Environment Variables
# =============================================================================

export ALTERNATE_EDITOR=""
export BAT_THEME="ansi"
export EDITOR='emacs'
export EMACSDIR="${HOME}/.emacs.d/"
export LESS="-RFX"

# =============================================================================
#                           Command Aliases
# =============================================================================

alias df='df -h'
alias du='du -h'
alias grep='grep --color=auto'
alias rm='rm -I'
alias xclip='xclip -selection clipboard'
alias xopen='xdg-open'

if command -v batcat >/dev/null 2>&1; then
    alias cat='batcat --paging=never --style=plain'
fi

if command -v eza >/dev/null 2>&1; then
    alias ls='eza --color=auto --group-directories-first'
    alias l='eza -lh'
    alias ll='eza -lh'
    alias lll='eza -lha'
    alias la='eza -ld .*'
    alias lt='eza -lh --sort=time'
else
    alias ls='ls --color=auto -v'
    alias l='ls -lh'
    alias ll='ls -lh'
    alias lll='ls -lha'
    alias la='ls -lhd .?*'
    alias lt='ls -lht'
fi

if command -v tree >/dev/null 2>&1; then
    alias tree='tree -C'
fi

# =============================================================================
#                           Emacs Integration
# =============================================================================

__emacs_client() {
    # Check if there's already a frame available, reuse it if so
    if emacsclient -n -e "(if (> (length (frame-list)) 1) 't)" 2>/dev/null | grep -q t; then
        emacsclient -n "$@"
    else
        emacsclient -c -n "$@"
    fi
}

# Emacs client aliases
alias cedit='emacsclient -c -nw'    # Console edit
alias wedit='__emacs_client'        # Window edit
alias start_emacs='emacs --daemon'  # Start daemon
alias stop_emacs='emacsclient -e "(kill-emacs)"'  # Stop daemon

# =============================================================================
#                           Git Prompt
# =============================================================================

typeset -A __git_large_repo_cache

__is_large_repo() {
    local git_dir="$1"

    if (( ${+__git_large_repo_cache["${git_dir}"]} )); then
        [[ "${__git_large_repo_cache["${git_dir}"]}" == "true" ]]
        return
    fi

    local is_large=false
    if [[ -d "${git_dir}/objects/pack" ]]; then
        local packs=("${git_dir}"/objects/pack/*.pack(N))
        (( ${#packs} > 5 )) && is_large=true
    fi

    __git_large_repo_cache["${git_dir}"]="${is_large}"
    [[ "${is_large}" == "true" ]]
}

# Sets __gp_* variables — called directly from precmd (no subshell)
__git_prompt_compute() {
    __gp_active=false
    __gp_branch=""
    __gp_detached=no
    __gp_behind=0
    __gp_ahead=0
    __gp_staged=0
    __gp_unmerged=0
    __gp_changed=0
    __gp_untracked=0
    __gp_stashed=0

    [[ "$PWD" == *"/.git"* ]] && return

    local git_dir
    if [[ -d ".git" ]]; then
        git_dir=".git"
    else
        git_dir=$(git rev-parse --git-dir 2>/dev/null) || return
    fi

    __gp_active=true

    local status_timeout=0.2
    local fast_timeout=0.05
    local large_repo=false

    if __is_large_repo "${git_dir}"; then
        status_timeout=0.1
        fast_timeout=0.03
        large_repo=true
    fi

    # Branch + upstream + ahead/behind + file status in a single call
    local untracked_opt="normal"
    [[ "${large_repo}" == "true" ]] && untracked_opt="no"

    local status_output=""
    if ! status_output=$(timeout "${status_timeout}s" git status \
            --porcelain=v2 --branch --untracked-files="${untracked_opt}" 2>/dev/null); then
        # Timed out — lightweight fallback
        __gp_branch=$(timeout "${fast_timeout}s" git symbolic-ref --short -q HEAD 2>/dev/null)
        if [[ -z "${__gp_branch}" ]]; then
            __gp_detached="yes"
            __gp_branch=$(timeout "${fast_timeout}s" git describe --exact-match --tags HEAD 2>/dev/null \
                          || timeout "${fast_timeout}s" git rev-parse --short HEAD 2>/dev/null)
        fi
        local staged_files changed_files
        staged_files=$(timeout "${fast_timeout}s" git diff --cached --name-only 2>/dev/null)
        changed_files=$(timeout "${fast_timeout}s" git diff --name-only 2>/dev/null)
        [[ -n "${staged_files}" ]] && __gp_staged=$(echo "${staged_files}" | wc -l)
        [[ -n "${changed_files}" ]] && __gp_changed=$(echo "${changed_files}" | wc -l)
        if [[ -f "${git_dir}/refs/stash" ]]; then
            __gp_stashed=$(timeout "${fast_timeout}s" git rev-list --walk-reflogs --count refs/stash 2>/dev/null || echo 0)
        fi
        return
    fi

    # Parse porcelain v2 output
    local line
    while IFS= read -r line; do
        case "${line}" in
            "# branch.head "*)
                __gp_branch="${line#\# branch.head }"
                [[ "${__gp_branch}" == "(detached)" ]] && __gp_detached="yes"
                ;;
            "# branch.ab "*)
                local ab="${line#\# branch.ab }"
                __gp_ahead="${ab%% *}"
                __gp_ahead="${__gp_ahead#+}"
                __gp_behind="${ab##* }"
                __gp_behind="${__gp_behind#-}"
                ;;
            "1 "* | "2 "*)
                local xy="${line:2:2}"
                local idx="${xy:0:1}" wt="${xy:1:1}"
                case "${idx}" in [MADRC]) ((__gp_staged++)) ;; U) ((__gp_unmerged++)) ;; esac
                case "${wt}" in [MD]) ((__gp_changed++)) ;; U) ((__gp_unmerged++)) ;; esac
                ;;
            "u "*)
                ((__gp_unmerged++))
                ;;
            "? "*)
                ((__gp_untracked++))
                ;;
        esac
    done <<< "${status_output}"

    # Detached HEAD: resolve to tag or short hash
    if [[ "${__gp_detached}" == "yes" ]]; then
        __gp_branch=$(timeout "${fast_timeout}s" git describe --exact-match --tags HEAD 2>/dev/null \
                      || timeout "${fast_timeout}s" git rev-parse --short HEAD 2>/dev/null)
    fi

    # Stash count
    if [[ -f "${git_dir}/refs/stash" ]]; then
        __gp_stashed=$(timeout "${fast_timeout}s" git rev-list --walk-reflogs --count refs/stash 2>/dev/null || echo 0)
    fi
}

# =============================================================================
#                           Prompt Configuration
# =============================================================================

__build_prompt() {
    local exit_code="$?"

    # Base prompt: user@host working_directory (truncated to 3 components)
    PROMPT='%{%F{135}%}%n@%M%{%f%} %3~'

    # Git info (sets __gp_* variables directly, no fork)
    __git_prompt_compute

    if [[ "${__gp_active}" == "true" ]]; then
        if [[ "${__gp_detached}" == "yes" ]]; then
            PROMPT+=" %{%F{200}%}${__gp_branch}%{%f%}"
        elif (( __gp_staged || __gp_unmerged || __gp_changed || __gp_untracked )); then
            PROMPT+=" %{%F{240}%}${__gp_branch}%{%f%}"
        else
            PROMPT+=" %{%F{22}%}${__gp_branch}%{%f%}"
        fi

        (( __gp_behind )) && PROMPT+=" %{%F{250}%}v${__gp_behind}%{%f%}"
        (( __gp_ahead  )) && PROMPT+=" %{%F{250}%}^${__gp_ahead}%{%f%}"
        (( __gp_staged    )) && PROMPT+=" %{%F{28}%}*${__gp_staged}%{%f%}"
        (( __gp_unmerged  )) && PROMPT+=" %{%F{196}%}${__gp_unmerged}%{%f%}"
        (( __gp_changed   )) && PROMPT+=" %{%F{166}%}+${__gp_changed}%{%f%}"
        (( __gp_untracked )) && PROMPT+=" %{%F{172}%}?${__gp_untracked}%{%f%}"
        (( __gp_stashed   )) && PROMPT+=" %{%F{26}%}S${__gp_stashed}%{%f%}"
    fi

    (( exit_code )) && PROMPT+=" %{%F{196}%}[${exit_code}]%{%f%}"

    PROMPT+=' %# '
}

precmd() { __build_prompt; }
