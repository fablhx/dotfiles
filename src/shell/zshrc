[[ $TERM == "dumb" ]] && unsetopt zle && PS1='$ ' && return

plugins=(
    compleat
    zsh-syntax-highlighting
    history-substring-search
)

source "${HOME}"/.oh-my-zsh/oh-my-zsh.sh

REPORTTIME=10
HISTSIZE=50000
SAVEHIST=50000

setopt append_history
setopt complete_in_word
setopt hist_expire_dups_first
setopt hist_find_no_dups
setopt hist_ignore_all_dups
setopt hist_ignore_dups
setopt hist_save_no_dups
setopt inc_append_history
setopt notify
setopt prompt_subst
setopt share_history

zstyle ':completion:*' menu select
zstyle ':completion:*' list-colors ${(s.:.)LS_COLORS}
zstyle ':completion:*' verbose yes
zstyle ':completion:*' group-name ''
zstyle ':completion:*:descriptions' format "$fg[yellow]%B--- %d%b"
zstyle ':completion:*:messages' format '%d'
zstyle ':completion:*:warnings' format "$fg[red]No matches$reset_color"
zstyle ':completion:*:corrections' format '%B%d (errors: %e)%b'

# This speeds up pasting w/ autosuggest
# https://github.com/zsh-users/zsh-autosuggestions/issues/238
pasteinit() {
  OLD_SELF_INSERT=${${(s.:.)widgets[self-insert]}[2,3]}
  zle -N self-insert url-quote-magic # I wonder if you'd need `.url-quote-magic`?
}

pastefinish() {
  zle -N self-insert $OLD_SELF_INSERT
}
zstyle :bracketed-paste-magic paste-init pasteinit
zstyle :bracketed-paste-magic paste-finish pastefinish

typeset -A ZSH_HIGHLIGHT_STYLES
ZSH_HIGHLIGHT_STYLES[path]=''

export ALTERNATE_EDITOR=""
export EDITOR='emacs';
export LESS="-RFX"

alias ls='ls --color=auto -v'
alias grep='grep --color=auto'
alias fgrep='fgrep --color=auto'
alias egrep='egrep --color=auto'

alias tree='tree -C'

alias xclip='xclip -selection clipboard'

alias l='ls -lh'
alias ll='ls -lh'
alias lll='ls -lha'
alias la='ls -lhd .?*'
alias lt='ls -lht'

alias rm='rm -i'

alias xopen='xdg-open'

alias ocaml='rlwrap -pMagenta ocaml'

alias pretty_py='autopep8 --in-place --aggressive --aggressive'

function __emacs_client() {
    # Check if Emacs frame exists
    if [ "$(emacsclient -n -e '(> (length (frame-list)) 1)')" = "t" ]; then
        emacsclient -n "$@"
    else
        emacsclient -c -n "$@"
    fi
}

function __emacs() {
    emacs "$@"
}

alias cedit='emacsclient -c -nw'
alias wedit='__emacs_client'
alias emacs='__emacs'
alias start_emacs='emacs --daemon'
alias stop_emacs='emacsclient -e "(kill-emacs)"'

# Optimized Git Prompt Function
__git_prompt() {
    local CACHE_DIR="${TMPDIR:-/tmp}/git_prompt_cache_${USER}_$$"
    local PWD_HASH=$(printf '%s' "$PWD" | md5sum | cut -c1-8)
    local CACHE_FILE="${CACHE_DIR}/${PWD_HASH}"
    local CACHE_TIMEOUT=3  # seconds - slightly longer for better performance

    # Create cache directory if it doesn't exist
    [[ ! -d "$CACHE_DIR" ]] && mkdir -p "$CACHE_DIR" 2>/dev/null

    # Check if cache is fresh and valid
    if [[ -f "$CACHE_FILE" ]]; then
        local file_time current_time git_head_time=0
        current_time=$(date +%s)
        file_time=$(stat -c %Y "$CACHE_FILE" 2>/dev/null) || return

        # Check if .git/HEAD is newer than cache (more reliable than timeout alone)
        if [[ -f ".git/HEAD" ]]; then
            git_head_time=$(stat -c %Y ".git/HEAD" 2>/dev/null || echo 0)
        elif [[ -f "$(git rev-parse --git-dir 2>/dev/null)/HEAD" ]]; then
            git_head_time=$(stat -c %Y "$(git rev-parse --git-dir)/HEAD" 2>/dev/null || echo 0)
        fi

        # Use cache if it's fresh AND newer than git changes
        if (( current_time - file_time < CACHE_TIMEOUT && file_time >= git_head_time )); then
            cat "$CACHE_FILE" 2>/dev/null && return
        fi
    fi

    # Quick check if we're in a git repo (with timeout for hanging repos)
    local git_dir
    if command -v timeout >/dev/null 2>&1; then
        git_dir=$(timeout 0.1s git rev-parse --git-dir 2>/dev/null) || return
    else
        git_dir=$(git rev-parse --git-dir 2>/dev/null) || return
    fi

    # Detect git version for compatibility
    local git_version_major git_version_minor
    local git_version_string=$(git --version 2>/dev/null | grep -oE '[0-9]+\.[0-9]+\.[0-9]+' | head -1)
    git_version_major=${git_version_string%%.*}
    local temp=${git_version_string#*.}
    git_version_minor=${temp%%.*}

    # Colors
    local color_detached="%{\033[38;5;200m%}"
    local color_dirty="%{\033[38;5;240m%}"
    local color_clean="%{\033[38;5;22m%}"
    local color_behind="%{\033[38;5;250m%}"
    local color_ahead="%{\033[38;5;250m%}"
    local color_staged="%{\033[38;5;28m%}"
    local color_unmerged="%{\033[38;5;196m%}"
    local color_changed="%{\033[38;5;166m%}"
    local color_untracked="%{\033[38;5;172m%}"
    local color_stashed="%{\033[38;5;26m%}"
    local reset_color="%{\033[0m%}"

    # Set GIT_DIR to avoid repeated path resolution
    export GIT_DIR="$git_dir"
    local GIT_WORK_TREE="${git_dir%/.git}"
    [[ "$GIT_WORK_TREE" == "$git_dir" ]] && GIT_WORK_TREE="$(dirname "$git_dir")"
    export GIT_WORK_TREE

    # Initialize variables
    local branch="" detached="no" behind=0 ahead=0
    local staged=0 unmerged=0 changed=0 untracked=0 stashed=0

    # Get branch name fast
    branch=$(git symbolic-ref --short -q HEAD 2>/dev/null)

    if [[ -z "$branch" ]]; then
        # We're in detached HEAD state
        detached="yes"
        branch=$(git describe --exact-match --tags HEAD 2>/dev/null || git rev-parse --short HEAD 2>/dev/null)
    else
        # Get ahead/behind count in one command
        local upstream
        upstream=$(git for-each-ref --format='%(upstream:short)' "$(git symbolic-ref -q HEAD)" 2>/dev/null)

        if [[ -n "$upstream" ]]; then
            local ahead_behind
            # Use --count for git 2.x, fallback to wc -l for git 1.8
            if [[ "$git_version_major" -gt 1 ]] || [[ "$git_version_major" -eq 1 && "$git_version_minor" -ge 9 ]]; then
                ahead_behind=$(git rev-list --left-right --count "$upstream...HEAD" 2>/dev/null)
                if [[ -n "$ahead_behind" ]]; then
                    behind=${ahead_behind%%[[:space:]]*}
                    ahead=${ahead_behind##*[[:space:]]}
                fi
            else
                # Git 1.8 fallback
                behind=$(git rev-list --left-only "$upstream...HEAD" 2>/dev/null | wc -l)
                ahead=$(git rev-list --right-only "$upstream...HEAD" 2>/dev/null | wc -l)
            fi
        fi
    fi

    # Get status information with optimized timeout and early exit
    local git_status
    # Use --porcelain=v1 for git 2.11+, fallback to --porcelain for older versions
    local porcelain_flag="--porcelain"
    if [[ "$git_version_major" -gt 2 ]] || [[ "$git_version_major" -eq 2 && "$git_version_minor" -ge 11 ]]; then
        porcelain_flag="--porcelain=v1"
    fi

    if command -v timeout >/dev/null 2>&1; then
        git_status=$(timeout 0.15s git status $porcelain_flag -uno --ignored=no 2>/dev/null)
    else
        git_status=$(git status $porcelain_flag -uno --ignored=no 2>/dev/null)
    fi

    # Process status with optimized counting - use v1 format for better performance
    if [[ -n "$git_status" ]]; then
        local counts
        counts=$(printf '%s\n' "$git_status" | awk '
            BEGIN { staged=0; unmerged=0; changed=0; untracked=0 }
            /^[MADRC]/ { staged++ }
            /^UU|^AA|^DD/ { unmerged++ }
            /^.[MD]/ { changed++ }
            /^\?\?/ { untracked++ }
            END { printf "%d %d %d %d\n", staged, unmerged, changed, untracked }
        ')
        local -a count_array=(${=counts})
        staged=${count_array[1]}
        unmerged=${count_array[2]}
        changed=${count_array[3]}
        untracked=${count_array[4]}
    fi

    # Get stash count with timeout and cache-friendly approach
    # Use --count for git 2.x, fallback to wc -l for git 1.8
    if [[ "$git_version_major" -gt 1 ]] || [[ "$git_version_major" -eq 1 && "$git_version_minor" -ge 9 ]]; then
        if command -v timeout >/dev/null 2>&1; then
            stashed=$(timeout 0.1s git rev-list --walk-reflogs --count refs/stash 2>/dev/null || echo 0)
        else
            stashed=$(git rev-list --walk-reflogs --count refs/stash 2>/dev/null || echo 0)
        fi
    else
        # Git 1.8 fallback
        if command -v timeout >/dev/null 2>&1; then
            stashed=$(timeout 0.1s git rev-list --walk-reflogs refs/stash 2>/dev/null | wc -l || echo 0)
        else
            stashed=$(git rev-list --walk-reflogs refs/stash 2>/dev/null | wc -l || echo 0)
        fi
    fi

    # Set branch color based on repository state
    local color_branch
    if [[ "$detached" == "yes" ]]; then
        color_branch="$color_detached"
    elif [[ "$staged" -ne 0 || "$unmerged" -ne 0 || "$changed" -ne 0 || "$untracked" -ne 0 ]]; then
        color_branch="$color_dirty"
    else
        color_branch="$color_clean"
    fi

    # Build prompt string efficiently
    local git_prompt=" $color_branch$branch${reset_color}"

    [[ "$behind" -gt 0 ]] && git_prompt+=" $color_behind↓$behind${reset_color}"
    [[ "$ahead" -gt 0 ]] && git_prompt+=" $color_ahead↑$ahead${reset_color}"
    [[ "$staged" -gt 0 ]] && git_prompt+=" $color_staged•$staged${reset_color}"
    [[ "$unmerged" -gt 0 ]] && git_prompt+=" $color_unmerged$unmerged${reset_color}"
    [[ "$changed" -gt 0 ]] && git_prompt+=" $color_changed+$changed${reset_color}"
    [[ "$untracked" -gt 0 ]] && git_prompt+=" $color_untracked…$untracked${reset_color}"
    [[ "$stashed" -gt 0 ]] && git_prompt+=" $color_stashed⚑$stashed${reset_color}"

    # Save to cache and output
    echo "$git_prompt" | tee "$CACHE_FILE"

    # Clean up environment variables
    unset GIT_DIR GIT_WORK_TREE
}

# Function to clear git prompt cache when changing directories
__git_prompt_chpwd() {
    local CACHE_DIR="${TMPDIR:-/tmp}/git_prompt_cache_${USER}_$$"
    local PWD_HASH=$(printf '%s' "$PWD" | md5sum | cut -c1-8)
    rm -f "${CACHE_DIR}/${PWD_HASH}" 2>/dev/null

    # Periodic cleanup of old cache files (every 100th cd)
    if (( RANDOM % 100 == 0 )); then
        find "$CACHE_DIR" -type f -mmin +10 -delete 2>/dev/null &
    fi
}

# Add hook to clear cache when changing directories
autoload -U add-zsh-hook
add-zsh-hook chpwd __git_prompt_chpwd

__build_prompt() {
    PROMPT=$'%{\033[38;5;135m%}%n@%m%{\033[0m%} %4(c:…/:)%3c'
    test -z "$TIS_CHOOSE" || PROMPT+=$' %{\033[00;36m%}{${TIS_CHOOSE##*/}}%{\033[0m%}'
    PROMPT+="$(__git_prompt)"
    PROMPT+=$'%(0?.. %{\033[38;5;196m%}[%?]%{\033[0m%}) %# '
}

precmd() { __build_prompt; }
