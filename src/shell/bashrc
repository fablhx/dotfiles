# =============================================================================
#                               Bash Configuration
# =============================================================================

# Early exit for dumb terminals
[[ $TERM == "dumb" ]] && PS1='$ ' && return

# =============================================================================
#                           Shell Completion
# =============================================================================

# Enable programmable completion features
if ! shopt -oq posix; then
  if [ -f /usr/share/bash-completion/bash_completion ]; then
    . /usr/share/bash-completion/bash_completion
  elif [ -f /etc/bash_completion ]; then
    . /etc/bash_completion
  fi
fi

# =============================================================================
#                           History Configuration
# =============================================================================

export HISTCONTROL=ignoredups:erasedups
export HISTSIZE=50000
export HISTFILESIZE=50000
shopt -s histappend

# =============================================================================
#                           Environment Variables
# =============================================================================

export ALTERNATE_EDITOR=""
export EDITOR='emacs'
export LESS="-RFX"

# =============================================================================
#                           Command Aliases
# =============================================================================

# Enhanced tool detection and alias setup
__setup_modern_aliases() {
    # Core command enhancements
    alias ls='ls --color=auto -v'
    alias grep='grep --color=auto'
    alias fgrep='fgrep --color=auto'
    alias egrep='egrep --color=auto'

    # Modern tool alternatives (with fallbacks)
    if command -v bat >/dev/null 2>&1; then
        alias cat='bat --paging=never --style=plain'
    fi

    # Prefer eza if available
    if command -v eza >/dev/null 2>&1; then
        alias ls='eza --color=auto --group-directories-first'
        alias l='eza -lh'
        alias ll='eza -lh'
        alias lll='eza -lha'
        alias la='eza -d .*'
        alias lt='eza -lht'
    else
        # Fallback to standard ls
        alias l='ls -lh'
        alias ll='ls -lh'
        alias lll='ls -lha'
        alias la='ls -lhd .?*'
        alias lt='ls -lht'
    fi

    # ripgrep with fallback
    command -v rg >/dev/null 2>&1 && alias grep='rg'

    # Tree with colors
    alias tree='tree -C'

    # Clipboard integration
    alias xclip='xclip -selection clipboard'

    # Enhanced safety aliases
    alias rm='rm -I'    # Prompt once if removing 3+ files

    # System integration
    alias xopen='xdg-open'
}

# Initialize aliases
__setup_modern_aliases

# =============================================================================
#                           Emacs Integration
# =============================================================================

# Smart emacsclient function
__emacs_client() {
    # Check if there's already a frame available, reuse it if so
    if emacsclient -n -e "(if (> (length (frame-list)) 1) 't)" 2>/dev/null | grep -q t; then
        emacsclient -n "$@"
    else
        emacsclient -c -n "$@"
    fi
}

# Emacs client aliases
alias cedit='emacsclient -c -nw'    # Console edit
alias wedit='__emacs_client'        # Window edit
alias start_emacs='emacs --daemon'  # Start daemon
alias stop_emacs='emacsclient -e "(kill-emacs)"'  # Stop daemon

# =============================================================================
#                           Git Prompt
# =============================================================================

# Highly optimized Git prompt function with advanced performance improvements
__git_prompt() {
    # Early exits and guards for performance
    [[ "$PWD" == *"/.git"* ]] && return  # Skip if inside .git directory
    [[ -d ".git" ]] || git rev-parse --git-dir >/dev/null 2>&1 || return  # Quick git repo check

    # Get git directory for repo size detection
    local git_dir
    git_dir=$(git rev-parse --git-dir 2>/dev/null) || return

    # Intelligent timeout scaling based on repo size
    local base_timeout=0.1
    local fast_timeout=0.05
    local slow_timeout=0.2

    # Detect large repos by .git directory size (approximate)
    if [[ -d "$git_dir/objects/pack" ]] && [[ $(find "$git_dir/objects/pack" -name "*.pack" 2>/dev/null | wc -l) -gt 5 ]]; then
        # Large repo detected - use faster timeouts and skip expensive operations
        base_timeout=0.05
        fast_timeout=0.03
        slow_timeout=0.1
        local large_repo=true
    else
        local large_repo=false
    fi

    # Colors for bash
    local color_detached="\[\033[38;5;200m\]"
    local color_dirty="\[\033[38;5;240m\]"
    local color_clean="\[\033[38;5;22m\]"
    local color_behind="\[\033[38;5;250m\]"
    local color_ahead="\[\033[38;5;250m\]"
    local color_staged="\[\033[38;5;28m\]"
    local color_unmerged="\[\033[38;5;196m\]"
    local color_changed="\[\033[38;5;166m\]"
    local color_untracked="\[\033[38;5;172m\]"
    local color_stashed="\[\033[38;5;26m\]"
    local reset_color="\[\033[0m\]"

    # Initialize variables
    local branch="" detached="no" behind=0 ahead=0
    local staged=0 unmerged=0 changed=0 untracked=0 stashed=0

    # Combined git command for branch info and status (optimization)
    local git_status_combined
    if command -v timeout >/dev/null 2>&1; then
        git_status_combined=$(timeout "${fast_timeout}s" git status --porcelain=v1 -b --untracked-files=no 2>/dev/null)
    else
        git_status_combined=$(git status --porcelain=v1 -b --untracked-files=no 2>/dev/null)
    fi

    # Parse branch info from combined output
    if [[ -n "$git_status_combined" ]]; then
        local branch_line
        branch_line=$(echo "$git_status_combined" | head -1)

        if [[ "$branch_line" =~ ^##\ ([^.]+) ]]; then
            branch="${BASH_REMATCH[1]}"

            # Extract ahead/behind from branch line if present
            if [[ "$branch_line" =~ \[ahead\s+([0-9]+)\] ]]; then
                ahead="${BASH_REMATCH[1]}"
            fi
            if [[ "$branch_line" =~ \[behind\s+([0-9]+)\] ]]; then
                behind="${BASH_REMATCH[1]}"
            fi
            if [[ "$branch_line" =~ \[ahead\s+([0-9]+),\s*behind\s+([0-9]+)\] ]]; then
                ahead="${BASH_REMATCH[1]}"
                behind="${BASH_REMATCH[2]}"
            fi
        fi

        # Handle detached HEAD case
        if [[ "$branch_line" =~ HEAD\ \(no\ branch\) ]] || [[ -z "$branch" ]]; then
            detached="yes"
            if command -v timeout >/dev/null 2>&1; then
                branch=$(timeout "${base_timeout}s" git describe --exact-match --tags HEAD 2>/dev/null || timeout "${base_timeout}s" git rev-parse --short HEAD 2>/dev/null)
            else
                branch=$(git describe --exact-match --tags HEAD 2>/dev/null || git rev-parse --short HEAD 2>/dev/null)
            fi
        fi
    fi

    # Process status information with shell built-ins (optimization)
    if [[ -n "$git_status_combined" ]]; then
        # Skip the branch line and process file status lines
        local status_lines
        status_lines=$(echo "$git_status_combined" | tail -n +2)

        # Use shell parameter expansion instead of AWK for better performance
        while IFS= read -r line; do
            [[ -z "$line" ]] && continue

            local index_status="${line:0:1}"
            local worktree_status="${line:1:1}"

            # Count staged files
            case "$index_status" in
                [MADRC]) ((staged++)) ;;
                U) ((unmerged++)) ;;
            esac

            # Count changed files
            case "$worktree_status" in
                [MD]) ((changed++)) ;;
                U) ((unmerged++)) ;;
            esac
        done <<< "$status_lines"
    fi

    # Untracked files with timeout (skip in large repos for performance)
    if [[ "$large_repo" != "true" ]]; then
        local untracked_files
        if command -v timeout >/dev/null 2>&1; then
            untracked_files=$(timeout "${slow_timeout}s" git ls-files --others --exclude-standard 2>/dev/null)
        else
            untracked_files=$(git ls-files --others --exclude-standard 2>/dev/null)
        fi

        # Count untracked files if we got them
        if [[ -n "$untracked_files" ]]; then
            untracked=$(printf '%s\n' "$untracked_files" | wc -l)
        fi
    fi

    # Conditional stash counting (skip in large repos or if stash is old)
    if [[ "$large_repo" != "true" ]] && [[ -f "$git_dir/refs/stash" ]]; then
        # Only check stash if it was modified recently (within 24 hours)
        if [[ $(find "$git_dir/refs/stash" -mtime -1 2>/dev/null) ]]; then
            if command -v timeout >/dev/null 2>&1; then
                stashed=$(timeout "${base_timeout}s" git rev-list --walk-reflogs --count refs/stash 2>/dev/null || echo 0)
            else
                stashed=$(git rev-list --walk-reflogs --count refs/stash 2>/dev/null || echo 0)
            fi
        fi
    fi

    # Set branch color based on repository state
    local color_branch
    if [[ "$detached" == "yes" ]]; then
        color_branch="$color_detached"
    elif [[ "$staged" -ne 0 || "$unmerged" -ne 0 || "$changed" -ne 0 || "$untracked" -ne 0 ]]; then
        color_branch="$color_dirty"
    else
        color_branch="$color_clean"
    fi

    # Build prompt string efficiently
    local git_prompt=" $color_branch$branch${reset_color}"

    [[ "$behind" -gt 0 ]] && git_prompt+=" $color_behind↓$behind${reset_color}"
    [[ "$ahead" -gt 0 ]] && git_prompt+=" $color_ahead↑$ahead${reset_color}"
    [[ "$staged" -gt 0 ]] && git_prompt+=" $color_staged•$staged${reset_color}"
    [[ "$unmerged" -gt 0 ]] && git_prompt+=" $color_unmerged$unmerged${reset_color}"
    [[ "$changed" -gt 0 ]] && git_prompt+=" $color_changed+$changed${reset_color}"
    [[ "$untracked" -gt 0 ]] && git_prompt+=" $color_untracked…$untracked${reset_color}"
    [[ "$stashed" -gt 0 ]] && git_prompt+=" $color_stashed⚑$stashed${reset_color}"

    echo "$git_prompt"
}

# =============================================================================
#                           Prompt Configuration
# =============================================================================

# Build custom prompt with git information
__build_prompt() {
    local exit_code="$?"

    # Base prompt: user@host working_directory
    PS1="\[\033[38;5;135m\]\u@\h\[\033[0m\] \w"

    # Add git information
    PS1+="$(__git_prompt) "

    # Add exit code if non-zero
    test "$exit_code" -eq 0 || PS1+="\[\033[38;5;196m\][$exit_code]\[\033[0m\] "

    # Final prompt character
    PS1+="\$ "
}

# Prompt settings
PROMPT_DIRTRIM=3
PROMPT_COMMAND=__build_prompt
