# =============================================================================
#                               Bash Configuration
# =============================================================================

# Early exit for dumb terminals
[[ $TERM == "dumb" ]] && PS1='$ ' && return

# =============================================================================
#                           Shell Completion
# =============================================================================

# Enable programmable completion features
if ! shopt -oq posix; then
  if [ -f /usr/share/bash-completion/bash_completion ]; then
    . /usr/share/bash-completion/bash_completion
  elif [ -f /etc/bash_completion ]; then
    . /etc/bash_completion
  fi
fi

# =============================================================================
#                           History Configuration
# =============================================================================

export HISTCONTROL=ignoredups:erasedups
export HISTSIZE=50000
export HISTFILESIZE=50000
shopt -s histappend

# =============================================================================
#                           Environment Variables
# =============================================================================

export ALTERNATE_EDITOR=""
export EDITOR='emacs'
export LESS="-RFX"

# =============================================================================
#                           Command Aliases
# =============================================================================

# Enhanced tool detection and alias setup
__setup_modern_aliases() {
    # Core command enhancements
    alias ls='ls --color=auto -v'
    alias grep='grep --color=auto'
    alias fgrep='fgrep --color=auto'
    alias egrep='egrep --color=auto'

    # Modern tool alternatives (with fallbacks)
    if command -v bat >/dev/null 2>&1; then
        alias cat='bat --paging=never --style=plain'
    fi

    # Prefer eza if available
    if command -v eza >/dev/null 2>&1; then
        alias ls='eza --color=auto --group-directories-first'
        alias l='eza -lh'
        alias ll='eza -lh'
        alias lll='eza -lha'
        alias la='eza -d .*'
        alias lt='eza -lht'
    else
        # Fallback to standard ls
        alias l='ls -lh'
        alias ll='ls -lh'
        alias lll='ls -lha'
        alias la='ls -lhd .?*'
        alias lt='ls -lht'
    fi

    # ripgrep with fallback
    command -v rg >/dev/null 2>&1 && alias grep='rg'

    # Tree with colors
    alias tree='tree -C'

    # Clipboard integration
    alias xclip='xclip -selection clipboard'

    # Enhanced safety aliases
    alias rm='rm -I'    # Prompt once if removing 3+ files

    # System integration
    alias xopen='xdg-open'
}

# Initialize aliases
__setup_modern_aliases

# =============================================================================
#                           Emacs Integration
# =============================================================================

# Smart emacsclient function
__emacs_client() {
    # Check if there's already a frame available, reuse it if so
    if emacsclient -n -e "(if (> (length (frame-list)) 1) 't)" 2>/dev/null | grep -q t; then
        emacsclient -n "$@"
    else
        emacsclient -c -n "$@"
    fi
}

# Emacs client aliases
alias cedit='emacsclient -c -nw'    # Console edit
alias wedit='__emacs_client'        # Window edit
alias start_emacs='emacs --daemon'  # Start daemon
alias stop_emacs='emacsclient -e "(kill-emacs)"'  # Stop daemon

# =============================================================================
#                           Git Prompt
# =============================================================================

# Optimized Git prompt function with timeouts and performance improvements
__git_prompt() {
    # Quick check if we're in a git repo with timeout
    local git_dir
    if command -v timeout >/dev/null 2>&1; then
        git_dir=$(timeout 0.2s git rev-parse --git-dir 2>/dev/null) || return
    else
        git_dir=$(git rev-parse --git-dir 2>/dev/null) || return
    fi

    # Colors for bash
    local color_detached="\[\033[38;5;200m\]"
    local color_dirty="\[\033[38;5;240m\]"
    local color_clean="\[\033[38;5;22m\]"
    local color_behind="\[\033[38;5;250m\]"
    local color_ahead="\[\033[38;5;250m\]"
    local color_staged="\[\033[38;5;28m\]"
    local color_unmerged="\[\033[38;5;196m\]"
    local color_changed="\[\033[38;5;166m\]"
    local color_untracked="\[\033[38;5;172m\]"
    local color_stashed="\[\033[38;5;26m\]"
    local reset_color="\[\033[0m\]"

    # Initialize variables
    local branch="" detached="no" behind=0 ahead=0
    local staged=0 unmerged=0 changed=0 untracked=0 stashed=0

    # Get branch name with timeout
    if command -v timeout >/dev/null 2>&1; then
        branch=$(timeout 0.1s git symbolic-ref --short -q HEAD 2>/dev/null)
    else
        branch=$(git symbolic-ref --short -q HEAD 2>/dev/null)
    fi

    if [[ -z "$branch" ]]; then
        # Detached HEAD state
        detached="yes"
        if command -v timeout >/dev/null 2>&1; then
            branch=$(timeout 0.1s git describe --exact-match --tags HEAD 2>/dev/null || timeout 0.1s git rev-parse --short HEAD 2>/dev/null)
        else
            branch=$(git describe --exact-match --tags HEAD 2>/dev/null || git rev-parse --short HEAD 2>/dev/null)
        fi
    else
        # Get ahead/behind count with timeout
        local upstream
        if command -v timeout >/dev/null 2>&1; then
            upstream=$(timeout 0.1s git for-each-ref --format='%(upstream:short)' "$(git symbolic-ref -q HEAD)" 2>/dev/null)
        else
            upstream=$(git for-each-ref --format='%(upstream:short)' "$(git symbolic-ref -q HEAD)" 2>/dev/null)
        fi

        if [[ -n "$upstream" ]]; then
            local ahead_behind
            if command -v timeout >/dev/null 2>&1; then
                ahead_behind=$(timeout 0.15s git rev-list --left-right --count "$upstream...HEAD" 2>/dev/null)
            else
                ahead_behind=$(git rev-list --left-right --count "$upstream...HEAD" 2>/dev/null)
            fi

            if [[ -n "$ahead_behind" ]]; then
                read behind ahead <<< "$ahead_behind"
            fi
        fi
    fi

    # Get repository status with timeout
    local git_status
    if command -v timeout >/dev/null 2>&1; then
        git_status=$(timeout 0.2s git status --porcelain=v1 2>/dev/null)
    else
        git_status=$(git status --porcelain=v1 2>/dev/null)
    fi

    # Process status information
    if [[ -n "$git_status" ]]; then
        local counts
        counts=$(printf '%s\n' "$git_status" | awk '
            BEGIN { staged=0; unmerged=0; changed=0; untracked=0 }
            /^[MADRC]/ { staged++ }
            /^UU|^AA|^DD/ { unmerged++ }
            /^.[MD]/ { changed++ }
            /^\?\?/ { untracked++ }
            END { printf "%d %d %d %d\n", staged, unmerged, changed, untracked }
        ')
        read staged unmerged changed untracked <<< "$counts"
    fi

    # Get stash count only if stashes exist (performance optimization)
    if [[ -f "$git_dir/refs/stash" ]]; then
        if command -v timeout >/dev/null 2>&1; then
            stashed=$(timeout 0.1s git rev-list --walk-reflogs --count refs/stash 2>/dev/null || echo 0)
        else
            stashed=$(git rev-list --walk-reflogs --count refs/stash 2>/dev/null || echo 0)
        fi
    fi

    # Set branch color based on repository state
    local color_branch
    if [[ "$detached" == "yes" ]]; then
        color_branch="$color_detached"
    elif [[ "$staged" -ne 0 || "$unmerged" -ne 0 || "$changed" -ne 0 || "$untracked" -ne 0 ]]; then
        color_branch="$color_dirty"
    else
        color_branch="$color_clean"
    fi

    # Build prompt string efficiently
    local git_prompt=" $color_branch$branch${reset_color}"

    [[ "$behind" -gt 0 ]] && git_prompt+=" $color_behind↓$behind${reset_color}"
    [[ "$ahead" -gt 0 ]] && git_prompt+=" $color_ahead↑$ahead${reset_color}"
    [[ "$staged" -gt 0 ]] && git_prompt+=" $color_staged•$staged${reset_color}"
    [[ "$unmerged" -gt 0 ]] && git_prompt+=" $color_unmerged$unmerged${reset_color}"
    [[ "$changed" -gt 0 ]] && git_prompt+=" $color_changed+$changed${reset_color}"
    [[ "$untracked" -gt 0 ]] && git_prompt+=" $color_untracked…$untracked${reset_color}"
    [[ "$stashed" -gt 0 ]] && git_prompt+=" $color_stashed⚑$stashed${reset_color}"

    echo "$git_prompt"
}

# =============================================================================
#                           Prompt Configuration
# =============================================================================

# Build custom prompt with git information
__build_prompt() {
    local exit_code="$?"

    # Base prompt: user@host working_directory
    PS1="\[\033[38;5;135m\]\u@\h\[\033[0m\] \w"

    # Add git information
    PS1+="$(__git_prompt) "

    # Add exit code if non-zero
    test "$exit_code" -eq 0 || PS1+="\[\033[38;5;196m\][$exit_code]\[\033[0m\] "

    # Final prompt character
    PS1+="\$ "
}

# Prompt settings
PROMPT_DIRTRIM=3
PROMPT_COMMAND=__build_prompt
