[[ $TERM == "dumb" ]] && PS1='$ ' && return

# enable programmable completion features (you don't need to enable
# this, if it's already enabled in /etc/bash.bashrc and /etc/profile
# sources /etc/bash.bashrc).
if ! shopt -oq posix; then
  if [ -f /usr/share/bash-completion/bash_completion ]; then
    . /usr/share/bash-completion/bash_completion
  elif [ -f /etc/bash_completion ]; then
    . /etc/bash_completion
  fi
fi

export HISTCONTROL=ignoredups:erasedups
export HISTSIZE=50000
export HISTFILESIZE=50000
shopt -s histappend

export ALTERNATE_EDITOR=""
export EDITOR='emacs'
export LESS="-RFX"

alias ls='ls --color=auto -v'
alias grep='grep --color=auto'
alias fgrep='fgrep --color=auto'
alias egrep='egrep --color=auto'

alias tree='tree -C'

alias xclip='xclip -selection clipboard'

alias l='ls -lh'
alias ll='ls -lh'
alias lll='ls -lha'
alias la='ls -lhd .?*'
alias lt='ls -lht'

alias rm='rm -i'

alias xopen='xdg-open'

alias ocaml='rlwrap -pMagenta ocaml'

__emacs_client() {
    # This check if I have already run an emacsclient --create-frame,
    # if yes, use the current frame, if no create a new frame.
    if emacsclient -n -e "(if (> (length (frame-list)) 1) 't)" | grep -q t;
    then
        emacsclient -n "$@"
    else
        emacsclient -c -n "$@"
    fi
}

__emacs() {
    emacs "$@"
}

alias cedit='emacsclient -c -nw'
alias wedit='__emacs_client'
alias emacs='__emacs'
alias start_emacs='emacs --daemon'
alias stop_emacs='emacsclient -e "(kill-emacs)"'

# Optimized Git Prompt Function for Bash
__git_prompt() {
    local CACHE_DIR="${TMPDIR:-/tmp}/git_prompt_cache_${USER}_$$"
    local PWD_HASH=$(printf '%s' "$PWD" | md5sum | cut -c1-8)
    local CACHE_FILE="${CACHE_DIR}/${PWD_HASH}"
    local CACHE_TIMEOUT=3  # seconds - slightly longer for better performance

    # Create cache directory if it doesn't exist
    [[ ! -d "$CACHE_DIR" ]] && mkdir -p "$CACHE_DIR" 2>/dev/null

    # Check if cache is fresh and valid
    if [[ -f "$CACHE_FILE" ]]; then
        local file_time current_time git_head_time=0
        current_time=$(date +%s)
        file_time=$(stat -c %Y "$CACHE_FILE" 2>/dev/null) || return

        # Check if .git/HEAD is newer than cache (more reliable than timeout alone)
        if [[ -f ".git/HEAD" ]]; then
            git_head_time=$(stat -c %Y ".git/HEAD" 2>/dev/null || echo 0)
        elif [[ -f "$(git rev-parse --git-dir 2>/dev/null)/HEAD" ]]; then
            git_head_time=$(stat -c %Y "$(git rev-parse --git-dir)/HEAD" 2>/dev/null || echo 0)
        fi

        # Use cache if it's fresh AND newer than git changes
        if (( current_time - file_time < CACHE_TIMEOUT && file_time >= git_head_time )); then
            cat "$CACHE_FILE" 2>/dev/null && return
        fi
    fi

    # Quick check if we're in a git repo (with timeout for hanging repos)
    local git_dir
    if command -v timeout >/dev/null 2>&1; then
        git_dir=$(timeout 0.1s git rev-parse --git-dir 2>/dev/null) || return
    else
        git_dir=$(git rev-parse --git-dir 2>/dev/null) || return
    fi

    # Colors for bash (different from zsh format)
    local color_detached="\[\033[38;5;200m\]"
    local color_dirty="\[\033[38;5;240m\]"
    local color_clean="\[\033[38;5;22m\]"
    local color_behind="\[\033[38;5;250m\]"
    local color_ahead="\[\033[38;5;250m\]"
    local color_staged="\[\033[38;5;28m\]"
    local color_unmerged="\[\033[38;5;196m\]"
    local color_changed="\[\033[38;5;166m\]"
    local color_untracked="\[\033[38;5;172m\]"
    local color_stashed="\[\033[38;5;26m\]"
    local reset_color="\[\033[0m\]"

    # Set GIT_DIR to avoid repeated path resolution
    export GIT_DIR="$git_dir"
    local GIT_WORK_TREE="${git_dir%/.git}"
    [[ "$GIT_WORK_TREE" == "$git_dir" ]] && GIT_WORK_TREE="$(dirname "$git_dir")"
    export GIT_WORK_TREE

    # Initialize variables
    local branch="" detached="no" behind=0 ahead=0
    local staged=0 unmerged=0 changed=0 untracked=0 stashed=0

    # Get branch name fast
    branch=$(git symbolic-ref --short -q HEAD 2>/dev/null)

    if [[ -z "$branch" ]]; then
        # We're in detached HEAD state
        detached="yes"
        branch=$(git describe --exact-match --tags HEAD 2>/dev/null || git rev-parse --short HEAD 2>/dev/null)
    else
        # Get ahead/behind count in one command
        local upstream
        upstream=$(git for-each-ref --format='%(upstream:short)' "$(git symbolic-ref -q HEAD)" 2>/dev/null)

        if [[ -n "$upstream" ]]; then
            local ahead_behind
            ahead_behind=$(git rev-list --left-right --count "$upstream...HEAD" 2>/dev/null)

            if [[ -n "$ahead_behind" ]]; then
                # Parse ahead_behind differently for bash
                behind=$(echo "$ahead_behind" | awk '{print $1}')
                ahead=$(echo "$ahead_behind" | awk '{print $2}')
            fi
        fi
    fi

    # Get status information with optimized timeout and early exit
    local git_status
    if command -v timeout >/dev/null 2>&1; then
        git_status=$(timeout 0.15s git status --porcelain=v1 -uno --ignored=no 2>/dev/null)
    else
        git_status=$(git status --porcelain=v1 -uno --ignored=no 2>/dev/null)
    fi

    # Process status with optimized counting - use v1 format for better performance
    if [[ -n "$git_status" ]]; then
        local counts
        counts=$(printf '%s\n' "$git_status" | awk '
            BEGIN { staged=0; unmerged=0; changed=0; untracked=0 }
            /^[MADRC]/ { staged++ }
            /^UU|^AA|^DD/ { unmerged++ }
            /^.[MD]/ { changed++ }
            /^\?\?/ { untracked++ }
            END { printf "%d %d %d %d\n", staged, unmerged, changed, untracked }
        ')
        read staged unmerged changed untracked <<< "$counts"
    fi

    # Get stash count with timeout and cache-friendly approach
    if command -v timeout >/dev/null 2>&1; then
        stashed=$(timeout 0.1s git rev-list --walk-reflogs --count refs/stash 2>/dev/null || echo 0)
    else
        stashed=$(git rev-list --walk-reflogs --count refs/stash 2>/dev/null || echo 0)
    fi

    # Set branch color based on repository state
    local color_branch
    if [[ "$detached" == "yes" ]]; then
        color_branch="$color_detached"
    elif [[ "$staged" -ne 0 || "$unmerged" -ne 0 || "$changed" -ne 0 || "$untracked" -ne 0 ]]; then
        color_branch="$color_dirty"
    else
        color_branch="$color_clean"
    fi

    # Build prompt string efficiently
    local git_prompt=" $color_branch$branch${reset_color}"

    [[ "$behind" -gt 0 ]] && git_prompt+=" $color_behind↓$behind${reset_color}"
    [[ "$ahead" -gt 0 ]] && git_prompt+=" $color_ahead↑$ahead${reset_color}"
    [[ "$staged" -gt 0 ]] && git_prompt+=" $color_staged•$staged${reset_color}"
    [[ "$unmerged" -gt 0 ]] && git_prompt+=" $color_unmerged$unmerged${reset_color}"
    [[ "$changed" -gt 0 ]] && git_prompt+=" $color_changed+$changed${reset_color}"
    [[ "$untracked" -gt 0 ]] && git_prompt+=" $color_untracked…$untracked${reset_color}"
    [[ "$stashed" -gt 0 ]] && git_prompt+=" $color_stashed⚑$stashed${reset_color}"

    # Save to cache and output
    echo "$git_prompt" | tee "$CACHE_FILE"

    # Clean up environment variables
    unset GIT_DIR GIT_WORK_TREE
}

# Function to clear git prompt cache when changing directories
__git_prompt_cd() {
    \cd "$@" || return
    local CACHE_DIR="${TMPDIR:-/tmp}/git_prompt_cache_${USER}_$$"
    local PWD_HASH=$(printf '%s' "$PWD" | md5sum | cut -c1-8)
    rm -f "${CACHE_DIR}/${PWD_HASH}" 2>/dev/null

    # Periodic cleanup of old cache files (every 100th cd)
    if (( RANDOM % 100 == 0 )); then
        find "$CACHE_DIR" -type f -mmin +10 -delete 2>/dev/null &
    fi
}

# Create alias to override cd with our custom function
alias cd="__git_prompt_cd"

__build_prompt() {
    local exit_code="$?"
    PS1="\[\033[38;5;135m\]\u@\h\[\033[0m\] \w"
    test -z "$TIS_CHOOSE" || PS1+=$' \[\033[00;36m\]{${TIS_CHOOSE##*/}}\[\033[0m\]'
    PS1+="$(__git_prompt) "
    test "$exit_code" -eq 0 || PS1+="\[\033[38;5;196m\][$exit_code]\[\033[0m\] "
    PS1+="\$ "
}

PROMPT_DIRTRIM=3
PROMPT_COMMAND=__build_prompt
