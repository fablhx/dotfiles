# =============================================================================
#                               Bash Configuration
# =============================================================================

# Early exit for dumb terminals
[[ $TERM == "dumb" ]] && PS1='$ ' && return

# =============================================================================
#                           Shell Completion
# =============================================================================

# Enable programmable completion features
if ! shopt -oq posix; then
  if [ -f /usr/share/bash-completion/bash_completion ]; then
    . /usr/share/bash-completion/bash_completion
  elif [ -f /etc/bash_completion ]; then
    . /etc/bash_completion
  fi
fi

# =============================================================================
#                           History Configuration
# =============================================================================

export HISTCONTROL=ignoredups:erasedups
export HISTSIZE=50000
export HISTFILESIZE=50000
shopt -s histappend

# =============================================================================
#                           Environment Variables
# =============================================================================

export ALTERNATE_EDITOR=""
export EDITOR='emacs'
export EMACSDIR="${HOME}/.emacs.d/"
export LESS="-RFX"

# =============================================================================
#                           Command Aliases
# =============================================================================

# Enhanced tool detection and alias setup
__setup_modern_aliases() {
    # Core command enhancements
    alias ls='ls --color=auto -v'
    alias grep='grep --color=auto'
    alias fgrep='fgrep --color=auto'
    alias egrep='egrep --color=auto'

    # Modern tool alternatives (with fallbacks)
    if command -v batcat >/dev/null 2>&1; then
        alias cat='batcat --paging=never --style=plain'
    fi

    # Prefer eza if available
    if command -v eza >/dev/null 2>&1; then
        alias ls='eza --color=auto --group-directories-first'
        alias l='eza -lh'
        alias ll='eza -lh'
        alias lll='eza -lha'
        alias la='eza -d .*'
        alias lt='eza -lht'
    else
        # Fallback to standard ls
        alias l='ls -lh'
        alias ll='ls -lh'
        alias lll='ls -lha'
        alias la='ls -lhd .?*'
        alias lt='ls -lht'
    fi

    # ripgrep with fallback
    if command -v rg >/dev/null 2>&1; then
        alias grep='rg'
    fi

    # Tree with colors
    if command -v tree >/dev/null 2>&1; then
        alias tree='tree -C'
    fi

    # Clipboard integration
    alias xclip='xclip -selection clipboard'

    # Enhanced safety aliases
    alias rm='rm -I'    # Prompt once if removing 3+ files

    # System integration
    alias xopen='xdg-open'
}

# Initialize aliases
__setup_modern_aliases

# =============================================================================
#                           Emacs Integration
# =============================================================================

# Smart emacsclient function
__emacs_client() {
    # Check if there's already a frame available, reuse it if so
    if emacsclient -n -e "(if (> (length (frame-list)) 1) 't)" 2>/dev/null | grep -q t; then
        emacsclient -n "$@"
    else
        emacsclient -c -n "$@"
    fi
}

# Emacs client aliases
alias cedit='emacsclient -c -nw'    # Console edit
alias wedit='__emacs_client'        # Window edit
alias start_emacs='emacs --daemon'  # Start daemon
alias stop_emacs='emacsclient -e "(kill-emacs)"'  # Stop daemon

# =============================================================================
#                           Git Prompt
# =============================================================================

# Highly optimized Git prompt function with advanced performance improvements
__git_prompt() {
    # Skip git prompt entirely if timeout command is not available
    # This simplifies the git prompt by requiring timeout for all git operations
    command -v timeout >/dev/null 2>&1 || return

    # Early exits and guards for performance
    [[ "$PWD" == *"/.git"* ]] && return  # Skip if inside .git directory
    [[ -d ".git" ]] || git rev-parse --git-dir >/dev/null 2>&1 || return  # Quick git repo check

    # Get git directory for repo size detection
    local git_dir
    git_dir=$(git rev-parse --git-dir 2>/dev/null) || return

    # Intelligent timeout scaling based on repo size
    local base_timeout=0.1
    local fast_timeout=0.05
    local slow_timeout=0.2

    # Detect large repos by .git directory size (approximate)
    if [[ -d "${git_dir}/objects/pack" ]] && [[ $(find "${git_dir}/objects/pack" -name "*.pack" 2>/dev/null | wc -l) -gt 5 ]]; then
        # Large repo detected - use faster timeouts and skip expensive operations
        base_timeout=0.05
        fast_timeout=0.03
        slow_timeout=0.1
        local large_repo=true
    else
        local large_repo=false
    fi

    # Initialize variables
    local branch="" detached="no" behind=0 ahead=0
    local staged=0 unmerged=0 changed=0 untracked=0 stashed=0

    # Get branch name separately for better reliability
    branch=$(timeout "${fast_timeout}s" git symbolic-ref --short -q HEAD 2>/dev/null)

    # Handle detached HEAD case
    if [[ -z "${branch}" ]]; then
        detached="yes"
        branch=$(timeout "${base_timeout}s" git describe --exact-match --tags HEAD 2>/dev/null || timeout "${base_timeout}s" git rev-parse --short HEAD 2>/dev/null)
    fi

    # Get status information with progressive fallback strategy
    local git_status_combined=""
    local using_fallback=false

    # Try git status with timeout
    git_status_combined=$(timeout "${fast_timeout}s" git status --porcelain --untracked-files=no 2>/dev/null)

    # If git status times out or fails, fall back to git diff --name-only
    if [[ $? -ne 0 ]]; then
        using_fallback=true
        # Get staged changes (index vs HEAD) and unstaged changes in parallel
        local staged_files changed_files
        local staged_tmp=$(mktemp)
        local changed_tmp=$(mktemp)
        timeout "${fast_timeout}s" git diff --cached --name-only 2>/dev/null > "${staged_tmp}" &
        local staged_pid=$!
        timeout "${fast_timeout}s" git diff --name-only 2>/dev/null > "${changed_tmp}" &
        local changed_pid=$!

        wait $staged_pid; staged_files=$(cat "${staged_tmp}" 2>/dev/null)
        wait $changed_pid; changed_files=$(cat "${changed_tmp}" 2>/dev/null)
        rm -f "${staged_tmp}" "${changed_tmp}"

        # Build status more efficiently
        git_status_combined=""
        [[ -n "${staged_files}" ]] && while read -r file; do git_status_combined+="M  $file"$'\n'; done <<< "${staged_files}"
        [[ -n "${changed_files}" ]] && while read -r file; do git_status_combined+=" M $file"$'\n'; done <<< "${changed_files}"
    fi

    # Get ahead/behind information separately if needed
    if [[ "${detached}" != "yes" ]]; then
        local upstream
        upstream=$(timeout "${fast_timeout}s" git rev-parse --abbrev-ref @{upstream} 2>/dev/null)

        if [[ -n "${upstream}" ]]; then
            local ahead_behind
            ahead_behind=$(timeout "${fast_timeout}s" git rev-list --left-right --count HEAD..."${upstream}" 2>/dev/null)

            # If that times out, try merge-base approach for faster check
            if [[ $? -ne 0 ]]; then
                local merge_base=$(timeout "${fast_timeout}s" git merge-base HEAD "${upstream}" 2>/dev/null)
                if [[ -n "${merge_base}" ]]; then
                    local head_commit=$(timeout "${fast_timeout}s" git rev-parse HEAD 2>/dev/null)
                    local upstream_commit=$(timeout "${fast_timeout}s" git rev-parse "${upstream}" 2>/dev/null)

                    if [[ -n "${head_commit}" && -n "${upstream_commit}" ]]; then
                        [[ "${merge_base}" != "${head_commit}" ]] && ahead="?"  # We're ahead, unknown count
                        [[ "${merge_base}" != "${upstream_commit}" ]] && behind="?"  # We're behind, unknown count
                    fi
                fi
            fi

            if [[ -n "${ahead_behind}" ]]; then
                ahead=$(echo "${ahead_behind}" | cut -f1)
                behind=$(echo "${ahead_behind}" | cut -f2)
            fi
        fi
    fi

    # Process status information with shell built-ins (optimization)
    if [[ -n "${git_status_combined}" ]]; then
        # Process all file status lines directly
        local status_lines
        status_lines="${git_status_combined}"

        # Use shell parameter expansion instead of AWK for better performance
        while IFS= read -r line; do
            [[ -z "${line}" ]] && continue

            local index_status="${line:0:1}"
            local worktree_status="${line:1:1}"

            # Count staged files
            case "${index_status}" in
                [MADRC]) ((staged++)) ;;
                U) ((unmerged++)) ;;
            esac

            # Count changed files
            case "${worktree_status}" in
                [MD]) ((changed++)) ;;
                U) ((unmerged++)) ;;
            esac
        done <<< "${status_lines}"
    fi

    # Untracked files with timeout (skip in large repos for performance)
    if [[ "${large_repo}" != "true" ]]; then
        local untracked_files
        untracked_files=$(timeout "${slow_timeout}s" git ls-files --others --exclude-standard 2>/dev/null)

        # Count untracked files if we got them
        if [[ -n "${untracked_files}" ]]; then
            untracked=$(printf '%s\n' "${untracked_files}" | wc -l)
        fi
    fi

    # Conditional stash counting (skip in large repos or if stash is old)
    if [[ "${large_repo}" != "true" ]] && [[ -f "${git_dir}/refs/stash" ]]; then
        # Only check stash if it was modified recently (within 24 hours)
        if [[ $(find "${git_dir}/refs/stash" -mtime -1 2>/dev/null) ]]; then
            stashed=$(timeout "${base_timeout}s" git rev-list --walk-reflogs --count refs/stash 2>/dev/null || echo 0)
        fi
    fi

    # Colors for bash
    local color_detached="\[\033[38;5;200m\]"
    local color_dirty="\[\033[38;5;240m\]"
    local color_clean="\[\033[38;5;22m\]"
    local color_behind="\[\033[38;5;250m\]"
    local color_ahead="\[\033[38;5;250m\]"
    local color_staged="\[\033[38;5;28m\]"
    local color_unmerged="\[\033[38;5;196m\]"
    local color_changed="\[\033[38;5;166m\]"
    local color_untracked="\[\033[38;5;172m\]"
    local color_stashed="\[\033[38;5;26m\]"
    local reset_color="\[\033[0m\]"

    # Set branch color based on repository state
    local color_branch
    if [[ "${detached}" == "yes" ]]; then
        color_branch="${color_detached}"
    elif [[ "${staged}" -ne 0 || "${unmerged}" -ne 0 || "${changed}" -ne 0 || "${untracked}" -ne 0 ]]; then
        color_branch="${color_dirty}"
    else
        color_branch="${color_clean}"
    fi

    # Build prompt string efficiently
    local git_prompt=" ${color_branch}${branch}${reset_color}"

    [[ "${behind}" -gt 0 ]] && git_prompt+=" ${color_behind}v${behind}${reset_color}"
    [[ "${ahead}" -gt 0 ]] && git_prompt+=" ${color_ahead}^${ahead}${reset_color}"
    [[ "${staged}" -gt 0 ]] && git_prompt+=" ${color_staged}*${staged}${reset_color}"
    [[ "${unmerged}" -gt 0 ]] && git_prompt+=" ${color_unmerged}${unmerged}${reset_color}"
    [[ "${changed}" -gt 0 ]] && git_prompt+=" ${color_changed}+${changed}${reset_color}"
    [[ "${untracked}" -gt 0 ]] && git_prompt+=" ${color_untracked}?${untracked}${reset_color}"
    [[ "${stashed}" -gt 0 ]] && git_prompt+=" ${color_stashed}S${stashed}${reset_color}"

    echo "${git_prompt}"
}

# =============================================================================
#                           Prompt Configuration
# =============================================================================

# Build custom prompt with git information
__build_prompt() {
    local exit_code="$?"

    # Base prompt: user@host working_directory
    PS1="\[\033[38;5;135m\]\u@\H\[\033[0m\] \w"

    # Add git information
    PS1+="$(__git_prompt)"

    # Add exit code if non-zero
    test "${exit_code}" -eq 0 || PS1+=" \[\033[38;5;196m\][${exit_code}]\[\033[0m\]"

    # Final prompt character
    PS1+=" \$ "
}

# Prompt settings
PROMPT_DIRTRIM=3
PROMPT_COMMAND="__build_prompt${PROMPT_COMMAND:+; $PROMPT_COMMAND}"
