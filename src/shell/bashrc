# =============================================================================
#                               Bash Configuration
#                             (Warp Terminal / Linux)
# =============================================================================

# Early exit for dumb terminals
[[ $TERM == "dumb" ]] && PS1='$ ' && return

# =============================================================================
#                           Shell Options
# =============================================================================

shopt -s cdspell          # Autocorrect minor cd typos
shopt -s checkwinsize     # Update LINES/COLUMNS after each command
shopt -s dirspell         # Autocorrect directory name typos in completion
shopt -s globstar         # Enable ** recursive glob
shopt -s histappend       # Append to history, don't overwrite

# =============================================================================
#                           Shell Completion
# =============================================================================

if ! shopt -oq posix; then
  if [ -f /usr/share/bash-completion/bash_completion ]; then
    . /usr/share/bash-completion/bash_completion
  elif [ -f /etc/bash_completion ]; then
    . /etc/bash_completion
  fi
fi

# =============================================================================
#                           History Configuration
# =============================================================================

export HISTCONTROL=ignoredups:erasedups
export HISTSIZE=50000
export HISTFILESIZE=50000
export HISTIGNORE="ls:ll:la:l:cd:pwd:exit:clear:history:bg:fg:jobs"

# =============================================================================
#                           Environment Variables
# =============================================================================

export ALTERNATE_EDITOR=""
export BAT_THEME="ansi"
export EDITOR='emacs'
export EMACSDIR="${HOME}/.emacs.d/"
export LESS="-RFX"

# =============================================================================
#                           Command Aliases
# =============================================================================

alias df='df -h'
alias du='du -h'
alias grep='grep --color=auto'
alias rm='rm -I'
alias xclip='xclip -selection clipboard'
alias xopen='xdg-open'

if command -v batcat >/dev/null 2>&1; then
    alias cat='batcat --paging=never --style=plain'
fi

if command -v eza >/dev/null 2>&1; then
    alias ls='eza --color=auto --group-directories-first'
    alias l='eza -lh'
    alias ll='eza -lh'
    alias lll='eza -lha'
    alias la='eza -ld .*'
    alias lt='eza -lh --sort=time'
else
    alias ls='ls --color=auto -v'
    alias l='ls -lh'
    alias ll='ls -lh'
    alias lll='ls -lha'
    alias la='ls -lhd .?*'
    alias lt='ls -lht'
fi

if command -v tree >/dev/null 2>&1; then
    alias tree='tree -C'
fi

# =============================================================================
#                           Emacs Integration
# =============================================================================

__emacs_client() {
    # Check if there's already a frame available, reuse it if so
    if emacsclient -n -e "(if (> (length (frame-list)) 1) 't)" 2>/dev/null | grep -q t; then
        emacsclient -n "$@"
    else
        emacsclient -c -n "$@"
    fi
}

# Emacs client aliases
alias cedit='emacsclient -c -nw'    # Console edit
alias wedit='__emacs_client'        # Window edit
alias start_emacs='emacs --daemon'  # Start daemon
alias stop_emacs='emacsclient -e "(kill-emacs)"'  # Stop daemon

# =============================================================================
#                           Git Info
# =============================================================================

# Uses `git status --porcelain=v2 --branch` to retrieve branch, upstream,

declare -A __git_large_repo_cache

__is_large_repo() {
    local git_dir="$1"

    if [[ -v __git_large_repo_cache["${git_dir}"] ]]; then
        [[ "${__git_large_repo_cache["${git_dir}"]}" == "true" ]]
        return
    fi

    local is_large=false
    if [[ -d "${git_dir}/objects/pack" ]]; then
        local packs=("${git_dir}"/objects/pack/*.pack)
        [[ -e "${packs[0]}" ]] && [[ ${#packs[@]} -gt 5 ]] && is_large=true
    fi

    __git_large_repo_cache["${git_dir}"]="${is_large}"
    [[ "${is_large}" == "true" ]]
}

__git_info_compute() {
    __gi_active=false
    __gi_branch=""
    __gi_detached=no
    __gi_behind=0
    __gi_ahead=0
    __gi_staged=0
    __gi_unmerged=0
    __gi_changed=0
    __gi_untracked=0
    __gi_stashed=0

    [[ "$PWD" == *"/.git"* ]] && return

    # Resolve git_dir
    local git_dir
    if [[ -d ".git" ]]; then
        git_dir=".git"
    else
        git_dir=$(git rev-parse --git-dir 2>/dev/null) || return
    fi

    __gi_active=true

    local status_timeout=0.2
    local fast_timeout=0.05
    local large_repo=false

    if __is_large_repo "${git_dir}"; then
        status_timeout=0.1
        fast_timeout=0.03
        large_repo=true
    fi

    # Branch + upstream + ahead/behind + file status
    local untracked_opt="normal"
    [[ "${large_repo}" == "true" ]] && untracked_opt="no"

    local status_output=""
    if ! status_output=$(timeout "${status_timeout}s" git status \
            --porcelain=v2 --branch --untracked-files="${untracked_opt}" 2>/dev/null); then
        # Timed out or failed â€” try lightweight fallback
        __gi_branch=$(timeout "${fast_timeout}s" git symbolic-ref --short -q HEAD 2>/dev/null)
        if [[ -z "${__gi_branch}" ]]; then
            __gi_detached="yes"
            __gi_branch=$(timeout "${fast_timeout}s" git describe --exact-match --tags HEAD 2>/dev/null \
                          || timeout "${fast_timeout}s" git rev-parse --short HEAD 2>/dev/null)
        fi
        # Fallback: try to get at least staged/changed counts
        local staged_files changed_files
        staged_files=$(timeout "${fast_timeout}s" git diff --cached --name-only 2>/dev/null)
        changed_files=$(timeout "${fast_timeout}s" git diff --name-only 2>/dev/null)
        [[ -n "${staged_files}" ]] && __gi_staged=$(echo "${staged_files}" | wc -l)
        [[ -n "${changed_files}" ]] && __gi_changed=$(echo "${changed_files}" | wc -l)
        # Stash
        if [[ -f "${git_dir}/refs/stash" ]]; then
            __gi_stashed=$(timeout "${fast_timeout}s" git rev-list --walk-reflogs --count refs/stash 2>/dev/null || echo 0)
        fi
        return
    fi

    # Parse porcelain v2 output
    while IFS= read -r line; do
        case "${line}" in
            "# branch.head "*)
                __gi_branch="${line#\# branch.head }"
                [[ "${__gi_branch}" == "(detached)" ]] && __gi_detached="yes"
                ;;
            "# branch.ab "*)
                # Format: "# branch.ab +3 -1"
                local ab="${line#\# branch.ab }"
                __gi_ahead="${ab%% *}"    # "+3"
                __gi_ahead="${__gi_ahead#+}"  # "3"
                __gi_behind="${ab##* }"   # "-1"
                __gi_behind="${__gi_behind#-}" # "1"
                ;;
            "1 "* | "2 "*)
                # Changed entries: "1 XY ..."  or  "2 XY ... (renames)"
                local xy="${line:2:2}"
                local idx="${xy:0:1}" wt="${xy:1:1}"
                case "${idx}" in [MADRC]) ((__gi_staged++)) ;; U) ((__gi_unmerged++)) ;; esac
                case "${wt}" in [MD]) ((__gi_changed++)) ;; U) ((__gi_unmerged++)) ;; esac
                ;;
            "u "*)
                # Unmerged entry
                ((__gi_unmerged++))
                ;;
            "? "*)
                # Untracked file
                ((__gi_untracked++))
                ;;
        esac
    done <<< "${status_output}"

    # Detached HEAD: resolve to tag or short hash
    if [[ "${__gi_detached}" == "yes" ]]; then
        __gi_branch=$(timeout "${fast_timeout}s" git describe --exact-match --tags HEAD 2>/dev/null \
                      || timeout "${fast_timeout}s" git rev-parse --short HEAD 2>/dev/null)
    fi

    # Stash count (not available via status --porcelain)
    if [[ -f "${git_dir}/refs/stash" ]]; then
        __gi_stashed=$(timeout "${fast_timeout}s" git rev-list --walk-reflogs --count refs/stash 2>/dev/null || echo 0)
    fi
}

__gi() {
    __git_info_compute

    if [[ "${__gi_active}" != "true" ]]; then
        echo "Not a git repository"
        return 1
    fi

    local rst=$'\033[0m'
    local out=""

    if [[ "${__gi_detached}" == "yes" ]]; then
        out+="\033[38;5;200m${__gi_branch}${rst}"
    elif [[ "${__gi_staged}" -ne 0 || "${__gi_unmerged}" -ne 0 || "${__gi_changed}" -ne 0 || "${__gi_untracked}" -ne 0 ]]; then
        out+="\033[38;5;240m${__gi_branch}${rst}"
    else
        out+="\033[38;5;22m${__gi_branch}${rst}"
    fi

    [[ "${__gi_behind}" != "0" ]]  && out+=" \033[38;5;250mv${__gi_behind}${rst}"
    [[ "${__gi_ahead}"  != "0" ]]  && out+=" \033[38;5;250m^${__gi_ahead}${rst}"
    [[ "${__gi_staged}"    -ne 0 ]] && out+=" \033[38;5;28m*${__gi_staged}${rst}"
    [[ "${__gi_unmerged}"  -ne 0 ]] && out+=" \033[38;5;196m${__gi_unmerged}${rst}"
    [[ "${__gi_changed}"   -ne 0 ]] && out+=" \033[38;5;166m+${__gi_changed}${rst}"
    [[ "${__gi_untracked}" -ne 0 ]] && out+=" \033[38;5;172m?${__gi_untracked}${rst}"
    [[ "${__gi_stashed}"   -ne 0 ]] && out+=" \033[38;5;26mS${__gi_stashed}${rst}"

    echo -e "Git info: ${out}"
}

alias gi='__gi'
